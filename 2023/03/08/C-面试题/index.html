<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Airex Yu">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/03/08/c-面试题/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="说说 C++ 中智能指针和指针的区别是什么？ 智能指针 如果在程序中使用 new 从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放 智能指针和普通指针的区别：智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。指针是一种数据类型，用于保存内存地址，而">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面试题">
<meta property="og:url" content="http://example.com/2023/03/08/C-%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="说说 C++ 中智能指针和指针的区别是什么？ 智能指针 如果在程序中使用 new 从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放 智能指针和普通指针的区别：智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。指针是一种数据类型，用于保存内存地址，而">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-08T03:09:21.000Z">
<meta property="article:modified_time" content="2023-05-25T13:22:34.471Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/%E9%B1%BC.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/%E9%B1%BC.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/%E9%B1%BC.svg">
    <!--- Page Info-->
    
    <title>
        
            C++面试题 -
        
        Airex-Daily
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/assets/fonts.css">

    <!--- Font Part-->
    
    
    
        <link href="" rel="stylesheet">
    
    
        <link href="" rel="stylesheet">
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":true,"family":null,"url":null},"english":{"enable":true,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"busuanzi_counter":{"enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"pjax":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fix","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-rry6gw.png"},"title":"伸手也握不住彩虹🌈","subtitle":{"text":["——我期待"],"hitokoto":{"enable":true,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/Airex-ai","instagram":null,"zhihu":null,"twitter":null,"email":"airex.yu@foxmail.com"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":"https://music.163.com/song?id=1501530173&userid=253099352","cover":null}]},"mermaid":{"enable":true,"version":"9.3.0"}},"version":"2.1.5","navbar":{"auto_hide":true,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"Github":"https://github.com/Airex-ai?tab=repositories"}},"随记":{"icon":"fa-solid fa-tree-palm","path":"/masonry/"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}}};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    Global.data_config = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Airex-Daily
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        归档
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/Airex-ai?tab=repositories">GITHUB
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/masonry/"  >
                                    
                                        
                                            <i class="fa-solid fa-tree-palm"></i>
                                        
                                        随记
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                归档
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://github.com/Airex-ai?tab=repositories">GITHUB</a>
                            </li>
                        
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/masonry/"  >
                             
                                
                                    <i class="fa-solid fa-tree-palm"></i>
                                
                                随记
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
             
                <div class="article-title">         
                    <img src="/images/C++.png" alt="C++面试题" />
                    <h1 class="article-title-cover">C++面试题</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/%E5%A4%B4%E5%83%8F.JPG">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Airex Yu</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-03-08 11:09:21</span>
        <span class="mobile">2023-03-08 11:09</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-05-25 21:22:34</span>
            <span class="mobile">2023-05-25 21:22</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/C/">C++</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="说说-C-中智能指针和指针的区别是什么？"><a href="#说说-C-中智能指针和指针的区别是什么？" class="headerlink" title="说说 C++ 中智能指针和指针的区别是什么？"></a>说说 C++ 中智能指针和指针的区别是什么？</h1><ol>
<li>智能指针 如果在程序中使用 new 从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放</li>
<li>智能指针和普通指针的区别：<strong>智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制</strong>，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。指针是一种数据类型，用于保存内存地址，而智能指针是类模板。</li>
</ol>
<h1 id="简述一下-C-中的多态"><a href="#简述一下-C-中的多态" class="headerlink" title="简述一下 C++ 中的多态"></a>简述一下 C++ 中的多态</h1><p>在面向对象中，多态是指通过基类的指针或者引用，在运行时动态调用实际绑定对象函数的行为，与之相对应的编译时绑定函数称为静态绑定。所以多态分为静态多态和动态多态。</p>
<p>静态多态 静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数就调用，没有的话就会发出警告或者报错</p>
<p>动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。当父类指针（引用）指向 父类对象时，就调用父类中定义的虚函数；即当父类指针（引用）指向 子类对象时，就调用子类中定义的虚函数。</p>
<p>加分回答 </p>
<ol>
<li><p>动态多态行为的表现效果为：同样的调用语句在实际运行时有多种不同的表现形态。</p>
</li>
<li><ol start="2">
<li>实现动态多态的条件： - 要有继承关系 - 要有虚函数重写（被 virtual 声明的函数叫虚函数） - 要有父类指针（父类引用）指向子类对象</li>
</ol>
</li>
<li><p>动态多态的实现原理：当类中声明虚函数时，编译器会在类中生成一个虚函数表， 虚函数表是由编译器自动生成与维护的。每个对象中都有一个指向虚函数表的指针（vptr 指针）。在多态调用时, vptr 指针就会根据这个对象在对应类的虚函数表中查找被调用的函数，从而找到函数的入口地址。</p>
</li>
</ol>
<h1 id="简述一下什么是面向对象"><a href="#简述一下什么是面向对象" class="headerlink" title="简述一下什么是面向对象"></a>简述一下什么是面向对象</h1><p>面向对象思想是基于面向过程思想的，要说面向对象思想，先说说面向过程思想</p>
<ol>
<li>面向过程思想 完成一个需求的步骤：首先是搞清楚要做什么，然后再分析怎么做，最后再通过代码体现。一步一步去实现，而具体的每一步都需要我们去实现和操作。面向过程编程，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能函数相互调用，完成需求。</li>
<li>面向对象以对象为核心，该思想认为程序由一系列对象组成。 面向对象思想的特点：是一种更符合人类思维习惯的思想 - 可以将复杂的问题简单化 - 将我们从执行者变成了指挥者</li>
<li>面向对象的三大特征：封装、继承、多态 - 封装：将事物属性和行为封装到一起，也就是 C++ 中的类，便于管理，提高代码的复用性。 - 继承：继承使类与类之间产生关系，能够提高代码的复用性以及可维护性。 - 多态：多态意味着调用成员函数时，会根据调用方法的对象的类型来执行不同的函数。 加分回答 面向过程和面向对象解决问题举例：以洗衣服为例。 1. 面向过程：接水到盆中 —— 放入衣服 —— 加入洗衣粉 —— 浸泡 —— 搓衣服 —— 过水 —— 拧干 —— 晾干 2. 面向对象：将衣服放入洗衣机 —— 加入洗衣粉 —— 开启 —— 晾干 通过例子可以发现面向对象的方式解决问题更加简单一些，但是面向对象还是基于面向过程的。</li>
</ol>
<h1 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h1><p> 面向对象的三大特征是：封装、继承、多态。</p>
<ol>
<li><p>封装 将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。 C++通过 private、protected、public 三个关键字来控制成员变量和成员函数的访问权限， - private 修饰的成员只能在本类中访问 - protected 表示受保护的权限，修饰的成员只能在本类或者子类中访问 - public 修饰的成员是公共的，哪儿都可用访问。</p>
</li>
<li><p>继承 C++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。</p>
</li>
<li><p>多态是指通过基类的指针或者引用，在运行时动态调用实际绑定对象函数的行为。多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。当父类指针（引用）指向 父类对象时，就调用父类中定义的虚函数；即当父类指针（引用）指向 子类对象时，就调用子类中定义的虚函数。</p>
</li>
</ol>
<h1 id="简述一下浅拷贝和深拷贝"><a href="#简述一下浅拷贝和深拷贝" class="headerlink" title="简述一下浅拷贝和深拷贝"></a>简述一下浅拷贝和深拷贝</h1><p>浅拷贝和深拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是“引用”。浅拷贝和深拷贝一般在拷贝构造函数和赋值运算符重载函数中涉及到。 </p>
<ol>
<li>浅拷贝：将源对象的值拷贝到目标对象中，如果对象中有某个成员是指针类型数据，并且是在堆区创建，则使用浅拷贝仅仅拷贝的是这个指针变量的值，也就是在目标对象中该指针类型数据和源对象中的该成员指向的是同一块堆空间。这样会带来一个问题，就是在析构函数中释放该堆区数据，会被释放多次。默认的拷贝构造函数和默认的赋值运算符重载函数都是浅拷贝。</li>
<li>深拷贝：深拷贝在拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样指针成员就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了拷贝的目的，还不会出现问题，两个对象先后去调用析构函数，分别释放自己指针成员所指向的内存。深拷贝情况下，不会出现重复释放同一块内存的错误。</li>
</ol>
<h1 id="请你说说-new-的实现原理，new-和-malloc-的区别"><a href="#请你说说-new-的实现原理，new-和-malloc-的区别" class="headerlink" title="请你说说 new 的实现原理，new 和 malloc 的区别"></a>请你说说 new 的实现原理，new 和 malloc 的区别</h1><p>new 的实现原理： 如果是简单类型，则直接调用 operator new()，在 operator new() 函数中会调用 malloc() 函数，如果调用 malloc() 失败会调用 **_callnewh()**，如果 _callnewh() 返回 0 则抛出 bac_alloc 异常，返回非零则继续分配内存。 如果是复杂类型，先调用 operator new()函数，然后在分配的内存上调用构造函数。</p>
<p>new 和 malloc 的区别：</p>
<ul>
<li><p>new 是操作符，而 malloc 是函数； </p>
</li>
<li><p>使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而 malloc 则需要显式地指出所需内存的尺寸； </p>
</li>
<li><p>new 分配失败的时候会直接抛出异常，malloc 分配失败会返回 NULL； </p>
</li>
<li><p>对于非简单类型，new 在分配内存后，会调用构造函数，而 malloc 不会； </p>
</li>
<li><p>new 分配成功后会返回对应类型的指针，而 malloc 分配成功后会返回 void * 类型； </p>
</li>
<li><p>malloc 可以分配任意字节，new 只能分配实例所占内存的整数倍数大小； </p>
</li>
<li><p>new 可以被重载，而 malloc 不能被重载； </p>
</li>
<li><p>使用 malloc 分配的内存后，如果在使用过程中发现内存不足，可以使用 realloc 函数进行内存重新分配实现内存的扩充，new 没有这样直观的配套设施来扩充内存。</p>
</li>
</ul>
<h1 id="说一说-STL-中有哪些常见的容器"><a href="#说一说-STL-中有哪些常见的容器" class="headerlink" title="说一说 STL 中有哪些常见的容器"></a>说一说 STL 中有哪些常见的容器</h1><p>顺序容器、关联式容器、容器适配器</p>
<ol>
<li>顺序容器：容器并非排序的，元素的插入位置同元素的值无关，包含 vector、deque、list。</li>
<li>关联式容器：元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现，包含set、multiset、map、multimap。</li>
<li>容器适配器：封装了一些基本的容器，使之具备了新的函数功能，包含 stack、queue、priority_queue。</li>
</ol>
<h1 id="STL-容器用过哪些，查找的时间复杂度是多少"><a href="#STL-容器用过哪些，查找的时间复杂度是多少" class="headerlink" title="STL 容器用过哪些，查找的时间复杂度是多少"></a>STL 容器用过哪些，查找的时间复杂度是多少</h1><p>标准回答 STL 中常用的容器有 vector、deque、list、map、set、multimap、multiset等</p>
<ol>
<li>vector 采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为： 插入: O(N) 查看: O(1) 删除: O(N) </li>
<li>deque 采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为： 插入: O(N) 查看: O(1) 删除: O(N) </li>
<li>list 采用双向链表实现，<strong>元素存放在堆中</strong>，不同操作的时间复杂度为： 插入: O(1) 查看: O(N) 删除: O(1)</li>
<li>map、set、multimap、multiset 上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为: 插入: O(logN) 查看: O(logN) 删除: O(logN)</li>
</ol>
<h1 id="简述一下堆和栈的区别"><a href="#简述一下堆和栈的区别" class="headerlink" title="简述一下堆和栈的区别"></a>简述一下堆和栈的区别</h1><ol>
<li>管理方式 对于栈来讲，是由编译器自动管理，无需手动控制；对于堆来说，分配和释放都是由程序员控制的</li>
<li>碎片问题 对于堆来讲，由于分配和释放是由程序员控制的，频繁的操作势必会造成内存空间的不连续，从而造成大量的内存碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的数据结构，在某一数据弹出之前，它之前的所有数据都已经弹出</li>
<li>生长方向 对于堆来讲，生长方向是向上的，也就是沿着内存地址增加的方向，对于栈来讲，它的生长方式是向下的，也就是沿着内存地址减小的方向增长。</li>
<li>分配方式 堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配，静态分配是编译器完成的，比如局部变量的分配；动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器实现的，无需我们手工实现。</li>
</ol>
<h1 id="请你说说指针和引用的区别"><a href="#请你说说指针和引用的区别" class="headerlink" title="请你说说指针和引用的区别"></a>请你说说指针和引用的区别</h1><ol>
<li>指针是一种数据类型，用于保存地址类型的数据，而引用可以看成是变量的别名。指针定义格式为：数据类型 *；而引用的定义格式为：数据类型 &amp;</li>
<li>引用不可以为空，当被创建的时候必须初始化，而指针变量可以是空值，在任何时候初始化</li>
<li>指针可以有多级，但引用只能是一级</li>
<li>sizeof 引用得到的是所指向的变量（对象）的大小，而 sizeof 指针得到的是指针变量本身的大小</li>
<li>指针作为函数参数传递时传递的是指针变量的值，而引用作为函数参数传递时传递的是实参本身，而不是拷贝副本</li>
</ol>
<h1 id="简述一下-C-的重载和重写"><a href="#简述一下-C-的重载和重写" class="headerlink" title="简述一下 C++ 的重载和重写"></a>简述一下 C++ 的重载和重写</h1><p>重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同（参数列表不同）。调用的时候根据函数的参数来区别不同的函数，函数重载跟返回值无关。重载用来实现静态多态，重载是多个函数或者同一个类中方法之间的关系，是平行关系。</p>
<p>重写是指在派生类中重新对基类中的<strong>虚函数</strong>重新实现。即函数名和参数都一样，只是函数的实现体不一样。  方法声明必须完全与父类中被重写的方法相同 - 访问修饰符的权限要大于或者等于父类中被重写的方法的访问修饰符 - 子类重写的方法可以加virtual，也可以不加。 重写用来实现动态多态。 重写是父类和子类之间的关系，是垂直关系。</p>
<h1 id="简述一下虚函数的实现原理"><a href="#简述一下虚函数的实现原理" class="headerlink" title="简述一下虚函数的实现原理"></a>简述一下虚函数的实现原理</h1><ol>
<li>虚函数的作用 C++ 中的虚函数的作用主要是实现了动态多态的机制。动态多态，简单的说就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。</li>
<li>虚函数实现原理 编译器处理虚函数时，给每个对象添加一个隐藏的成员。隐藏的成员是一个指针类型的数据，指向的是函数地址数组，这个数组被称为虚函数表。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚函数表中保存的是派生类的虚函数地址，如果派生类没有重写基类中的虚函数，则派生类对象的虚函数表中保存的是父类的虚函数地址。</li>
</ol>
<p>对于内存和执行速度方面会有一定的成本： 1. 每个对象都会变大，变大的量为存储虚函数表指针； 2. 对于每个类，编译器都会创建一个虚函数表； 3. 对于每次调用虚函数，都需要额外执行一个操作，就是到表中查找虚函数地址。</p>
<h1 id="说一说-C-和-C-中-struct-的区别以及和-class-的区别"><a href="#说一说-C-和-C-中-struct-的区别以及和-class-的区别" class="headerlink" title="说一说 C++ 和 C 中 struct 的区别以及和 class 的区别"></a>说一说 C++ 和 C 中 struct 的区别以及和 class 的区别</h1><ol>
<li>C 的结构体不允许有函数存在，C++ 的结构体允许有内部成员函数，并且允许该函数是虚函数</li>
<li>C 的结构体内部成员不能加权限，默认是 public，而 C++ 的结构体内部成员权限可以是 public、protected、private，默认 public </li>
<li>C 的结构体是不可以继承，C++ 的结构体可以从其它的结构体或者类继承</li>
<li>C 中的结构体不能直接初始化数据成员，C++ 中可以</li>
</ol>
<p><strong>struct 和 class 的区别</strong></p>
<ol>
<li>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装</li>
<li>struct 中默认访问控制权限是 public，而 class 中默认的访问控制权限是 private </li>
<li>在继承关系中，struct 默认是公有继承，而 class 是私有继承 </li>
<li>class 关键字可以用于定义模板参数，而 struct 不能</li>
</ol>
<h1 id="为什么将析构函数设置成虚函数"><a href="#为什么将析构函数设置成虚函数" class="headerlink" title="为什么将析构函数设置成虚函数"></a>为什么将析构函数设置成虚函数</h1><p>虚析构函数的主要作用是为了防止遗漏资源的释放，防止内存泄露。如果基类中的析构函数没有声明为虚函数，基类指针指向派生类对象时，则当基类指针释放时不会调用派生类对象的析构函数，而是调用基类的析构函数，如果派生类析构函数中做了某些释放资源的操作，则这时就会造成内存泄露</p>
<h1 id="请你说说-malloc-的实现原理"><a href="#请你说说-malloc-的实现原理" class="headerlink" title="请你说说 malloc 的实现原理"></a>请你说说 malloc 的实现原理</h1><p> malloc() 基本的实现原理就是维护一个内存空闲链表，当申请内存空间时，搜索内存空闲链表，找到适配的空闲内存空间，然后将空间分割成两个内存块，一个变成分配块，一个变成新的空闲块。如果没有搜索到，那么就申请内存空间。搜索空闲块最常见的算法有：首次适配，下一次适配，最佳适配。 - 首次适配：第一次找到足够大的内存块就分配，这种方法会产生很多的内存碎片。 - 下一次适配：也就是说等第二次找到足够大的内存块就分配，这样会产生比较少的内存碎片。 - 最佳适配：对堆进行彻底的搜索，从头开始遍历所有块，使用数据区大小大于 size 且差值最小的块作为此次分配的块。 在释放内存块后，如果不进行合并，那么相邻的空闲内存块还是相当于两个内存块，会形成一种假碎片。所以当释放内存后，需要将两个相邻的内存块进行合并。</p>
<h1 id="请你说说-delete-和-free-的区别"><a href="#请你说说-delete-和-free-的区别" class="headerlink" title="请你说说 delete 和 free 的区别"></a>请你说说 delete 和 free 的区别</h1><ol>
<li><p>delete 是操作符，而 free 是函数；</p>
</li>
<li><p>delete 用于释放 new 分配的空间，free 有用释放 malloc 分配的空间；</p>
</li>
<li><p>free 会不会调用对象的析构函数，而 delete 会调用对象的析构函数；</p>
</li>
<li><p>调用 free 之前需要检查要释放的指针是否为 NULL，使用 delete 释放内存则不需要检查指针是否为 NULL；</p>
</li>
</ol>
<h1 id="说一说什么是内存泄露，如何检测"><a href="#说一说什么是内存泄露，如何检测" class="headerlink" title="说一说什么是内存泄露，如何检测"></a>说一说什么是内存泄露，如何检测</h1><p>是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。避免内存泄露的方法主要就是要有良好的编码习惯，动态开辟内存空间，及时释放内存。也可以采用智能指针来避免内存泄露。</p>
<h1 id="说一说-vector-和-list-的区别，分别适用于什么场景？"><a href="#说一说-vector-和-list-的区别，分别适用于什么场景？" class="headerlink" title="说一说 vector 和 list 的区别，分别适用于什么场景？"></a>说一说 vector 和 list 的区别，分别适用于什么场景？</h1><p>区别 - vector 底层实现是数组，list 是双向链表 - vector 支持随机访问，list 不支持 - vector 是顺序内存，list 不是 - <strong>vector 在中间节点进行插入删除会导致内存拷贝，list 不会</strong> - <strong>vector 一次性分配好内存，不够时才进行扩容，list 每次插入新节点都会进行内存申请</strong> - vector 随机访问性能好，插入删除性能差，list 随机访问性能差，插入删除性能好 </p>
<h1 id="请你说说-map，unordered-map-的区别"><a href="#请你说说-map，unordered-map-的区别" class="headerlink" title="请你说说 map，unordered_map 的区别"></a>请你说说 map，unordered_map 的区别</h1><ol>
<li>导入的头文件 map：#include &lt;map&gt; unordered_map：#include &lt;unordered_map&gt; </li>
<li>原理及特点 map：内部实现了一个红黑树，该结构具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素，因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了 map 的效率。 unordered_map：内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。</li>
</ol>
<h1 id="请你说说-C-语言里面-volatile，可以和-const-同时使用吗"><a href="#请你说说-C-语言里面-volatile，可以和-const-同时使用吗" class="headerlink" title="请你说说 C 语言里面 volatile，可以和 const 同时使用吗"></a>请你说说 C 语言里面 volatile，可以和 const 同时使用吗</h1><p>volatile限定符是用来告诉计算机，所修饰的变量的值随时都会改变。用于防止编译器对代码的优化，换句话说，就是编译器在用到这个变量的时候都要从内存中重新读取这个变量的值，而不是使用保存在寄存器中的备份。const所修饰的变量的值在代码中不能进行修改，两者不冲突，可以一起使用</p>
<h1 id="说一说-static-关键字的作用"><a href="#说一说-static-关键字的作用" class="headerlink" title="说一说 static 关键字的作用"></a>说一说 static 关键字的作用</h1><ol>
<li>限制数据的作用域（隐藏） 所有没有加 static 的全局变量和函数都具有全局可见性，其它源文件中也可以访问</li>
<li>延长数据的生命周期 普通的局部变量出了作用域就会释放，而静态变量存储在静态区，知道程序运行结束才会释放</li>
<li>静态成员被该类所有对象共享 static 关键字可以修饰类中的成员变量和成员方法，被称为静态成员变量和静态成员方法，静态成员拥有一块单独的存储区，不管创建多少个该类的对象，所有对象都共享这一块内存</li>
<li>静态成员函数中不能访问普通的成员变量，只能访问静态成员变量，并且在静态成员函数中没有 this 指针</li>
</ol>
<h1 id="说一说什么是野指针，怎么产生的，如何避免"><a href="#说一说什么是野指针，怎么产生的，如何避免" class="headerlink" title="说一说什么是野指针，怎么产生的，如何避免"></a>说一说什么是野指针，怎么产生的，如何避免</h1><p>野指针是指指向的位置是随机的、不可知的、不正确的</p>
<p>野指针产生的原因：</p>
<ol>
<li>指针变量未初始化或者随便赋值</li>
<li>指针释放后未置空</li>
<li>指针操作超出了变量的作用域</li>
</ol>
<p>如何避免野指针 ：指针变量一定要初始化，可以初始化为 nullptr；释放后置为 nullptr。</p>
<h1 id="说说-const-和-define-的区别"><a href="#说说-const-和-define-的区别" class="headerlink" title="说说 const 和 define 的区别"></a>说说 const 和 define 的区别</h1><ol>
<li>const 生效于编译阶段，而 define 生效于预处理阶段；</li>
<li>define只是简单的字符串替换，没有类型检查，而 const 有对应的数据类型，编译器要进行判断的，可以避免一些低级的错误；</li>
<li>用 define 定义的常量是不可以用指针变量去指向的，用 const 定义的常量是可以用指针去指向该常量的地址的；</li>
<li>define 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大，const 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝；</li>
<li>可以对 const 常量进行调试，但是不能对宏常量进行调试。</li>
</ol>
<h1 id="请你说说-vector-的扩容机制，扩容以后，它的内存地址会变化吗？"><a href="#请你说说-vector-的扩容机制，扩容以后，它的内存地址会变化吗？" class="headerlink" title="请你说说 vector 的扩容机制，扩容以后，它的内存地址会变化吗？"></a>请你说说 vector 的扩容机制，扩容以后，它的内存地址会变化吗？</h1><p>步骤：</p>
<ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间</li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中</li>
<li>最后将旧的内存空间释放</li>
</ol>
<p>因为 vector 扩容需要申请新的空间，所以扩容以后它的内存地址会发生改变。vector 扩容是非常耗时的，为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间</p>
<h1 id="说一说什么是大端、小端，如何判断大端和小端"><a href="#说一说什么是大端、小端，如何判断大端和小端" class="headerlink" title="说一说什么是大端、小端，如何判断大端和小端"></a>说一说什么是大端、小端，如何判断大端和小端</h1><p>大端字节序：是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处 </p>
<p>小端字节序：是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处 </p>
<p>如何判断大端还是小端：可以定义一个联合体，联合体中有一个 short 类型的数据，有一个 char 类型的数组，数组大小为 short 类型的大小。给 short 类型成员赋值一个十六进制数 0x0102，然后输出根据数组第一个元素和第二个元素的结果来判断是大端还是小端</p>
<h1 id="简述-C-的内存管理"><a href="#简述-C-的内存管理" class="headerlink" title="简述 C++ 的内存管理"></a>简述 C++ 的内存管理</h1><ol>
<li>代码区 加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的</li>
<li>未初始化数据区 <strong>加载的是可执行文件 BSS 段</strong>，位置可以分开也可以紧靠数据段，存储于数据段的数据的生存周期为整个程序运行过程</li>
<li>已初始化数据区 <strong>加载的是可执行文件数据段</strong>，存储于数据段的数据的生存周期为整个程序运行过程</li>
<li>栈区 栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量</li>
<li>堆区 堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序，用于动态内存分配</li>
</ol>
<h1 id="什么是纯虚函数，有什么作用"><a href="#什么是纯虚函数，有什么作用" class="headerlink" title="什么是纯虚函数，有什么作用"></a>什么是纯虚函数，有什么作用</h1><p>纯虚函数不给出具体的实现，也就是后面没有大括号实现体，而在后面加上 “&#x3D;0”</p>
<p> 作用：很多情况下，在基类中不能对虚函数给出具体的有意义的实现，就可以把它声明为纯虚函数，它的实现留给该基类的派生类去做</p>
<p>特点：如果一个类中有纯虚函数，那么这个类也被称为抽象类。这种类不能实例化对象，也就是不能创建该类的对象。除非在派生类中完全实现基类中所有的纯虚函数，否则派生类也是抽象类，不能实例化对象。</p>
<h1 id="请你说说虚函数和纯虚函数的区别"><a href="#请你说说虚函数和纯虚函数的区别" class="headerlink" title="请你说说虚函数和纯虚函数的区别"></a>请你说说虚函数和纯虚函数的区别</h1><p>虚函数可以有具体的实现，纯虚函数没有具体的实现</p>
<p>对于虚函数来说，父类和子类都有各自的版本，由多态方式调用的时候动态绑定。 有纯虚函数的类称为抽象类，有纯虚函数的类不能实例化，派生类必须实现纯虚函数才可以实例化，否则也是抽象类</p>
<h1 id="简述-vector-的实现原理"><a href="#简述-vector-的实现原理" class="headerlink" title="简述 vector 的实现原理"></a>简述 vector 的实现原理</h1><ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间；</li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中；</li>
<li>最后将旧的内存空间释放。 vector 扩容是非常耗时的。为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间</li>
</ol>
<h1 id="请你说说-deque-的实现原理"><a href="#请你说说-deque-的实现原理" class="headerlink" title="请你说说 deque 的实现原理"></a>请你说说 deque 的实现原理</h1><p>deque 是由一段一段的定量的连续空间构成。一旦有必要在 deque 前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在 deque 的头端或者尾端。deque 采取一块所谓的 map作为主控，其中每一个元素都是一个指针，指向另一段连续性内存空间，称作缓冲区。通过中央控制，维持整体连续的假象</p>
<h1 id="请你说说-map-实现原理，各操作的时间复杂度是多少"><a href="#请你说说-map-实现原理，各操作的时间复杂度是多少" class="headerlink" title="请你说说 map 实现原理，各操作的时间复杂度是多少"></a>请你说说 map 实现原理，各操作的时间复杂度是多少</h1><p>map 实现原理 map 内部实现了一个红黑树，红黑树有自动排序的功能，因此 map 内部所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。</p>
<p>各操作的时间复杂度 插入: O(logN) 查看: O(logN) 删除: O(logN)</p>
<h1 id="shared-ptr-怎么知道跟它共享对象的指针释放了"><a href="#shared-ptr-怎么知道跟它共享对象的指针释放了" class="headerlink" title="shared_ptr 怎么知道跟它共享对象的指针释放了"></a>shared_ptr 怎么知道跟它共享对象的指针释放了</h1><p>智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。仅当最后一个指针过期时，才调用 delete。</p>
<h1 id="请你说说-extern-的作用，extern变量在哪个数据段，为什么要-extern-C"><a href="#请你说说-extern-的作用，extern变量在哪个数据段，为什么要-extern-C" class="headerlink" title="请你说说 extern 的作用，extern变量在哪个数据段，为什么要 extern C"></a>请你说说 extern 的作用，extern变量在哪个数据段，为什么要 extern C</h1><ol>
<li>extern 可以置于变量声明或者函数声明前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其它文件中寻找其定义</li>
<li>extern 变量是一个全局变量，保存在静态存储区（全局区），全局变量如果没有显示初始化，会默认初始化为 0，保存在程序的 BSS 段，如果初始化不为 0 则保存在程序的 DATA 段</li>
<li>在 C++ 出现以前，很多代码都是 C 语言写的，而且很底层的库也是 C 语言写的，为了更好的支持原来的 C 代码和已经写好的 C 语言库，需要在 C++ 中尽可能的支持 C。C语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名，extern “C” 的作用是为了能够正确的实现 C++ 代码调用 C 语言代码。</li>
</ol>
<h1 id="简述一下-C-中的内存对齐"><a href="#简述一下-C-中的内存对齐" class="headerlink" title="简述一下 C++ 中的内存对齐"></a>简述一下 C++ 中的内存对齐</h1><p>现代计算机中内存空间都是按照 字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数 k（通常它为4或8）的倍数，这就是所谓的内存对齐。 </p>
<p>内存对齐的原因：平台原因，不是所有的硬件平台都能访问任意地址上的任意数据的，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存访问仅需要一次访问。</p>
<h1 id="请你说说-set-的实现原理"><a href="#请你说说-set-的实现原理" class="headerlink" title="请你说说 set 的实现原理"></a>请你说说 set 的实现原理</h1><p>set 容器中每一个元素就是二叉树的每一个节点，对于 set 容器的插入删除操作，效率都比较高，原因是二叉树的删除插入元素并不需要进行内存拷贝和内存移动，只是改变了指针的指向。 对 set 进行插入删除操作 都不会引起迭代器的失效，因为迭代器相当于一个指针指向每一个二叉树的节点，对 set的插入删除并不会改变原有内存中节点的改变。</p>
<p>set 中的元素都是唯一的，而且默认情况下会对元素进行升序排列。不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，再插入新元素。不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取。</p>
<h1 id="请你回答一下智能指针有没有内存泄露的情况"><a href="#请你回答一下智能指针有没有内存泄露的情况" class="headerlink" title="请你回答一下智能指针有没有内存泄露的情况"></a>请你回答一下智能指针有没有内存泄露的情况</h1><p>当两个类对象中各自有一个 shared_ptr 指向对方时，会造成循环引用，使引用计数失效，从而导致内存泄露。 为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，<strong>但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</strong></p>
<h1 id="请你说说动态库静态库的区别和优缺点"><a href="#请你说说动态库静态库的区别和优缺点" class="headerlink" title="请你说说动态库静态库的区别和优缺点"></a>请你说说动态库静态库的区别和优缺点</h1><p>链接时间和方式不同 ： 静态库的链接是将整个函数库的所有数据在编译时都整合进了目标代码 - 动态库的链接是程序执行到哪个函数链接哪个函数的库</p>
<ol>
<li>静态库优缺点 - 优点：发布程序时无需提供静态库，移植方便，运行速度相对快些 - 缺点：静态链接生成的可执行文件体积较大，消耗内存，如果所使用的静态库发生更新改变，程序必须重新编译，更新麻烦。</li>
<li>态库优缺点 - 优点：更加节省内存并减少页面交换，动态库改变并不影响使用的程序，动态函数库升级比较方便 - 缺点：<strong>发布程序时需要提供动态库</strong></li>
</ol>
<h1 id="说说-C-语言和-C-语言的区别"><a href="#说说-C-语言和-C-语言的区别" class="headerlink" title="说说 C 语言和 C++ 语言的区别"></a>说说 C 语言和 C++ 语言的区别</h1><ol>
<li>C 语言是面向过程的语言，而 C++ 支持面向对象</li>
<li>C++ 支持函数重载，C 语言不支持</li>
<li>C 程序中如果函数没有任何参数需要将参数定义为 void 以此来限定函数不可传递任何参数，如果不进行限定让参数表默认为空其意义是可以传递任何参数，在 C++ 中，不带参数的函数表示函数不能传递任何参数；</li>
<li>C 语言 struct 中不能有函数，而 C++ 语言 struct 中可以有函数</li>
<li>C 语言函数参数不支持默认值，而 C++ 语言支持参数默认值</li>
<li>C++ 语言支持内联函数，而 C 语言不支持</li>
<li>C 语言采用 malloc 和 free 函数动态申请和释放内存，而 C++ 使用 new 和 delete 运算符</li>
<li>C 语言中只有局部和全局两个作用域，而 C++ 中有局部、全局、类、名称空间作用域</li>
</ol>
<h1 id="简述一下-C-中的四种类型转换"><a href="#简述一下-C-中的四种类型转换" class="headerlink" title="简述一下 C++ 中的四种类型转换"></a>简述一下 C++ 中的四种类型转换</h1><ul>
<li><p>静态转换 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换 - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的 - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</p>
</li>
<li><p>动态转换 dynamic_cast 主要用于类层次间的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的 在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全 </p>
</li>
<li><p>常量转换 该运算符用来修改类型的const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 常量引用被转换成非常量引用，并且仍然指向原来的对象 注意:<strong>不能直接对非指针和非引用的变量使用 const_cast 操作符</strong></p>
</li>
<li><p>重新解释转换 这是最不安全的一种转换机制，最有可能出问题 主要用于将一种数据类型从一种类型转换为另一种类型</p>
</li>
</ul>
<h1 id="请你说说-const-的用法"><a href="#请你说说-const-的用法" class="headerlink" title="请你说说 const 的用法"></a>请你说说 const 的用法</h1><ol>
<li>用在变量身上，表示该变量只读，不能对它的值进行修改</li>
<li>结合指针一起使用，有两种</li>
<li>const 用于形参时说明<strong>形参</strong>在函数内部不能被改变</li>
<li><strong>在类中修饰成员方法</strong>，防止在方法中修改非 static 成员</li>
<li>const 修饰类的成员变量，类的成员变量可以分为静态的和非静态的，如果 const 修饰的是非静态的成员变量，可以在构造函数中对该变量进行初始化；如果 const 修饰的是静态的成员变量，则需要在类外对该变量进行初始化。</li>
</ol>
<h1 id="请你说说C-引用的概念"><a href="#请你说说C-引用的概念" class="headerlink" title="请你说说C++引用的概念"></a>请你说说C++引用的概念</h1><p>引用（Reference）是 C++ 相对于 C 语言的一个扩充。引用可以看做是数据的一个别名，基本语法 typename &amp; ref &#x3D; varname;</p>
<p>注意：引用必须引用合法的内存空间 - 引用在定义时必须初始化 - 引用一旦初始化后，就不能再引用其它数据</p>
<p>引用的本质是指针，低层的实现还是指针。</p>
<h1 id="说说内联函数和函数的区别，内联函数的作用"><a href="#说说内联函数和函数的区别，内联函数的作用" class="headerlink" title="说说内联函数和函数的区别，内联函数的作用"></a>说说内联函数和函数的区别，内联函数的作用</h1><p>内联函数和函数的区别;</p>
<ol>
<li>内联函数比普通函数多了关键字 inline</li>
<li>内联函数避免了函数调用的开销；普通函数有调用的开销</li>
<li>普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址</li>
<li>联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句，如果内联函数函数体过于复杂，编译器将自动把内联函数当成普通函数来执行；普通函数没有这个要求</li>
</ol>
<p>作用：通过编译器预处理，在调用内联函数的地方将内联函数内的语句复制到调用函数的地方，也就是直接展开代码执行，从而提高了效率，减少了一些不必要的开销。同时内联函数还能解决宏定义的问题。</p>
<h1 id="请你说说虚函数可以是内联函数吗"><a href="#请你说说虚函数可以是内联函数吗" class="headerlink" title="请你说说虚函数可以是内联函数吗"></a>请你说说虚函数可以是内联函数吗</h1><p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</p>
<p>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可以内联。</p>
<p><strong>唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</strong></p>
<h1 id="请你说说迭代器失效原因，有哪些情况"><a href="#请你说说迭代器失效原因，有哪些情况" class="headerlink" title="请你说说迭代器失效原因，有哪些情况"></a>请你说说迭代器失效原因，有哪些情况</h1><p>序列式容器迭代器失效：对于序列式容器，例如 vector、deque，由于序列式容器是组合式容器，当当前元素的迭代器被删除后，其后的所有元素的迭代器都会失效。这是因为 vector、deque都是连续存储的一段空间，所以当对其进行 erase 操作时，<strong>其后的每一个元素都会向前移一个位置</strong>。解决：erase 返回下一个有效的迭代器。</p>
<p> 关联式容器迭代器失效：对于关联容器，仅仅会使当前的迭代器失效，只要在 erase 时，递增当前迭代器即可。这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个节点不会对其他点造成影响。erase 迭代器只是被删元素的迭代器失效，所以要采用 erase(iter++) 自增方式删除迭代器</p>
<h1 id="请你说说-auto-和-decltype-如何使用"><a href="#请你说说-auto-和-decltype-如何使用" class="headerlink" title="请你说说 auto 和 decltype 如何使用"></a>请你说说 auto 和 decltype 如何使用</h1><p>auto 实现<strong>自动类型推断</strong>，要求进行显示初始化，让编译器能够将变量的类型设置为初始值的类型： auto a &#x3D; 12; </p>
<p>decltype 将变量的类型声明为<strong>表达式指定的类型</strong>，decltype(x) y; &#x2F;&#x2F; 让y的类型与x相同</p>
<h1 id="请你说说什么情况会调用拷贝构造，什么时候会调用赋值操作"><a href="#请你说说什么情况会调用拷贝构造，什么时候会调用赋值操作" class="headerlink" title="请你说说什么情况会调用拷贝构造，什么时候会调用赋值操作"></a>请你说说什么情况会调用拷贝构造，什么时候会调用赋值操作</h1><p>拷贝构造函数的调用时机：用一个对象初始化另外一个对象 - <strong>对象以值传递的方式传递给函数参数，函数局部对象以值传递的方式从函数返回</strong></p>
<p>赋值操作的调用时机：将一个对象赋值给另外一个对象</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> C++面试题</li>
        <li><strong>作者:</strong> Airex Yu</li>
        <li><strong>创建于:</strong> 2023-03-08 11:09:21</li>
        
            <li>
                <strong>更新于:</strong> 2023-05-25 21:22:34
            </li>
        
        <li>
            <strong>链接:</strong> http://example.com/2023/03/08/C-面试题/
        </li>
        <li>
            <strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/03/10/ROS/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">ROS</span>
                                    <span class="post-nav-item">上一篇</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/03/06/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">自动驾驶</span>
                                    <span class="post-nav-item">下一篇</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
                <div class="comment-container">
                    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;评论
    </div>
    

        
            
 
    <div id="waline"></div>
    <script type="module"  data-pjax>
        import { init } from 'https://evan.beee.top/js/waline.mjs';

        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://example.example.com',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
            });
        }

        if ('true') {
            const loadWalineTimeout = setTimeout(() => {
                loadWaline();
                clearTimeout(loadWalineTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadWaline);
        }
        
    </script>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">C++面试题</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">说说 C++ 中智能指针和指针的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81"><span class="nav-text">简述一下 C++ 中的多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">简述一下什么是面向对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-text">简述一下面向对象的三大特征</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">简述一下浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-new-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8Cnew-%E5%92%8C-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">请你说说 new 的实现原理，new 和 malloc 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-STL-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-text">说一说 STL 中有哪些常见的容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL-%E5%AE%B9%E5%99%A8%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-text">STL 容器用过哪些，查找的时间复杂度是多少</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">简述一下堆和栈的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">请你说说指针和引用的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-text">简述一下 C++ 的重载和重写</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">简述一下虚函数的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-C-%E5%92%8C-C-%E4%B8%AD-struct-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">说一说 C++ 和 C 中 struct 的区别以及和 class 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">为什么将析构函数设置成虚函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-malloc-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">请你说说 malloc 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-delete-%E5%92%8C-free-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">请你说说 delete 和 free 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B"><span class="nav-text">说一说什么是内存泄露，如何检测</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-vector-%E5%92%8C-list-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-text">说一说 vector 和 list 的区别，分别适用于什么场景？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-map%EF%BC%8Cunordered-map-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">请你说说 map，unordered_map 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-C-%E8%AF%AD%E8%A8%80%E9%87%8C%E9%9D%A2-volatile%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%92%8C-const-%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%90%97"><span class="nav-text">请你说说 C 语言里面 volatile，可以和 const 同时使用吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-static-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">说一说 static 关键字的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="nav-text">说一说什么是野指针，怎么产生的，如何避免</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-const-%E5%92%8C-define-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">说说 const 和 define 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-vector-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%89%A9%E5%AE%B9%E4%BB%A5%E5%90%8E%EF%BC%8C%E5%AE%83%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E4%BC%9A%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F"><span class="nav-text">请你说说 vector 的扩容机制，扩容以后，它的内存地址会变化吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E3%80%81%E5%B0%8F%E7%AB%AF%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF"><span class="nav-text">说一说什么是大端、小端，如何判断大端和小端</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">简述 C++ 的内存管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-text">什么是纯虚函数，有什么作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">请你说说虚函数和纯虚函数的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-vector-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">简述 vector 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-deque-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">请你说说 deque 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-map-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E5%90%84%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-text">请你说说 map 实现原理，各操作的时间复杂度是多少</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#shared-ptr-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E8%B7%9F%E5%AE%83%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88%E9%87%8A%E6%94%BE%E4%BA%86"><span class="nav-text">shared_ptr 怎么知道跟它共享对象的指针释放了</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-extern-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8Cextern%E5%8F%98%E9%87%8F%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%AE%B5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81-extern-C"><span class="nav-text">请你说说 extern 的作用，extern变量在哪个数据段，为什么要 extern C</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-text">简述一下 C++ 中的内存对齐</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-set-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">请你说说 set 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E6%B2%A1%E6%9C%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">请你回答一下智能指针有没有内存泄露的情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">请你说说动态库静态库的区别和优缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E8%AF%AD%E8%A8%80%E5%92%8C-C-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">说说 C 语言和 C++ 语言的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">简述一下 C++ 中的四种类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-const-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">请你说说 const 的用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4C-%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">请你说说C++引用的概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">说说内联函数和函数的区别，内联函数的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%90%97"><span class="nav-text">请你说说虚函数可以是内联函数吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5"><span class="nav-text">请你说说迭代器失效原因，有哪些情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-auto-%E5%92%8C-decltype-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">请你说说 auto 和 decltype 如何使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%B0%83%E7%94%A8%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-text">请你说说什么情况会调用拷贝构造，什么时候会调用赋值操作</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Airex Yu</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br>
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.1.5</a>
        </div>
        
        
        
            <div id="start_div" style="display:none">
                2023/01/05 11:45:14
            </div>
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>



    
<script src="/js/tools/localSearch.js"></script>




    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>




    
<script src="/js/libs/mermaid.min.js"></script>

    
<script src="/js/plugins/mermaid.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/tools/tocToggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>

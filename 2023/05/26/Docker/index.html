<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Airex Yu">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/05/26/docker/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="Docker 简介和安装简介 Docker 是什么  Docker 是一个应用打包、分发、部署的工具你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。  跟普通虚拟机的对比     特性 普通虚拟机 Docker    跨平台 通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="http://example.com/2023/05/26/Docker/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Docker 简介和安装简介 Docker 是什么  Docker 是一个应用打包、分发、部署的工具你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。  跟普通虚拟机的对比     特性 普通虚拟机 Docker    跨平台 通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526103446032.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526103502908.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527103144634.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526104922907.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526105116820.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526105353853.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526105621213.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230601144227352.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526131919282.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526132857569.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526132951992.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526135407657.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526140156470.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526140256997.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526140426429.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/docker%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526150541837.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526153959896.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526182110494.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526182421354.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526185317735.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526202341404.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526202806979.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526203016899.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526204241163.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526204407002.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526204637050.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530160628154.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230526210224424.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527152727531.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527153130778.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527153552080.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527153858425.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527154435772.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527145122234.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527145359274.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527145535023.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527145947209.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527150027978.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527150124754.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527150939246.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527151018737.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527151203025.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527155909620.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527163209810.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230527181807514.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529091642584.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529094924865.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529095511093.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529095939846.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529141020895.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529141255019.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529141600377.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529103529387.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529105628572.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529144908767.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529145018617.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529145234897.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529145638397.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529145836844.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529145918330.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529150412262.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230529184825067.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530091117121.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530091205598.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530092341732.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530092547672.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530094119225.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530134925856.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530135241669.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530135811529.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530140651661.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530150427202.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530153258742.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530153327270.png">
<meta property="og:image" content="http://example.com/2023/05/26/Docker/image-20230530153439471.png">
<meta property="article:published_time" content="2023-05-26T01:31:49.000Z">
<meta property="article:modified_time" content="2023-07-02T07:13:45.477Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/05/26/Docker/image-20230526103446032.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/%E9%B1%BC.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/%E9%B1%BC.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/%E9%B1%BC.svg">
    <!--- Page Info-->
    
    <title>
        
            Docker -
        
        Airex-Daily
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/assets/fonts.css">

    <!--- Font Part-->
    
    
    
        <link href="" rel="stylesheet">
    
    
        <link href="" rel="stylesheet">
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":true,"family":null,"url":null},"english":{"enable":true,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"busuanzi_counter":{"enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"pjax":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fix","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-rry6gw.png"},"title":"伸手也握不住彩虹🌈","subtitle":{"text":["——我期待"],"hitokoto":{"enable":true,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/Airex-ai","instagram":null,"zhihu":null,"twitter":null,"email":"airex.yu@foxmail.com"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":"https://music.163.com/song?id=1501530173&userid=253099352","cover":null}]},"mermaid":{"enable":true,"version":"9.3.0"}},"version":"2.1.5","navbar":{"auto_hide":true,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"Github":"https://github.com/Airex-ai?tab=repositories"}},"随记":{"icon":"fa-solid fa-tree-palm","path":"/masonry/"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}}};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    Global.data_config = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Airex-Daily
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        归档
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/Airex-ai?tab=repositories">GITHUB
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/masonry/"  >
                                    
                                        
                                            <i class="fa-solid fa-tree-palm"></i>
                                        
                                        随记
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                归档
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://github.com/Airex-ai?tab=repositories">GITHUB</a>
                            </li>
                        
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/masonry/"  >
                             
                                
                                    <i class="fa-solid fa-tree-palm"></i>
                                
                                随记
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
             
                <div class="article-title">         
                    <img src="/images/docker.png" alt="Docker" />
                    <h1 class="article-title-cover">Docker</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/%E5%A4%B4%E5%83%8F.JPG">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Airex Yu</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-05-26 09:31:49</span>
        <span class="mobile">2023-05-26 09:31</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-07-02 15:13:45</span>
            <span class="mobile">2023-07-02 15:13</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/docker/">docker</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="Docker-简介和安装"><a href="#Docker-简介和安装" class="headerlink" title="Docker 简介和安装"></a>Docker 简介和安装</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Docker 是什么</p>
</blockquote>
<p>Docker 是一个应用打包、分发、部署的工具<br>你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，<br>而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p>
<blockquote>
<p>跟普通虚拟机的对比</p>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th>普通虚拟机</th>
<th>Docker</th>
</tr>
</thead>
<tbody><tr>
<td>跨平台</td>
<td>通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在不带图形界面的服务器上运行</td>
<td>支持的系统非常多，各类 windows 和 Linux 都支持</td>
</tr>
<tr>
<td>性能</td>
<td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td>
<td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td>
</tr>
<tr>
<td>自动化</td>
<td>需要手动安装所有东西</td>
<td>一个命令就可以自动部署好所需环境</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定性不高，不同系统差异大</td>
<td>稳定性好，不同系统都一样部署方式</td>
</tr>
</tbody></table>
<blockquote>
<p>打包、分发、部署</p>
</blockquote>
<p><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包<br><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装<br><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。</p>
<blockquote>
<p>Docker 部署的优势</p>
</blockquote>
<p>常规应用开发部署方式：自己在 Windows 上开发、测试 –&gt; 到 Linux 服务器配置运行环境部署。</p>
<p>用 Docker 开发部署流程：自己在 Windows 上开发、测试 –&gt; 打包为 Docker 镜像（可以理解为软件安装包） –&gt; 各种服务器上只需要一个命令部署好</p>
<ul>
<li>优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。</li>
</ul>
<blockquote>
<p>Docker 通常用来做什么</p>
</blockquote>
<ul>
<li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li>
<li>快速安装测试&#x2F;学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis &#x2F; MongoDB &#x2F; ElasticSearch &#x2F; ELK</li>
<li>多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0</li>
<li>Windows 上体验&#x2F;学习各种 Linux 系统</li>
</ul>
<blockquote>
<p>重要概念：镜像、容器、仓库</p>
</blockquote>
<p><strong>镜像</strong>：镜像是一个只读的模板，它包含了构建和运行容器所需的文件系统、应用程序和依赖项等。镜像可以看作是容器的<strong>静态快照</strong>，它是通过 Dockerfile 文件或从已有的镜像派生而来的。</p>
<p><strong>容器</strong>：容器是在镜像的基础上创建的一个运行实例。容器是一个轻量级的、可独立运行的环境，其中包含了运行应用程序所需的所有组件和资源。容器可以被启动、停止、删除等操作，并且可以在不同的主机上移植和共享。镜像是容器的基础，可以通过镜像创建多个相互独立的容器实例。</p>
<p><strong>仓库：</strong>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。Registry包括公开与私有两种。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>桌面版：<a class="link"   target="_blank" rel="noopener" href="https://www.docker.com/products/docker-desktop" >https://www.docker.com/products/docker-desktop <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>服务器版：<a class="link"   target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/#server" >https://docs.docker.com/engine/install/#server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<blockquote>
<p>启动报错解决</p>
</blockquote>
<p>报错截图</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526103446032.png"
                      class="" title="image-20230526103446032"
                >

<p><strong>解决方法</strong>：<br>控制面板-&gt;程序-&gt;启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2)</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526103502908.png"
                      class="" title="image-20230526103502908"
                >



<blockquote>
<p>命令行安装与卸载Linux内核</p>
</blockquote>
<p><strong>安装：</strong></p>
<p><code>wsl.exe --install -d Ubuntu</code></p>
<blockquote>
<p>wsl.exe 是 Windows Subsystem for Linux（WSL）的命令行工具，用于管理WSL子系统。–install选项表示安装WSL子系统，-d选项后紧跟着的Ubuntu参数表示要安装的Linux发行版为Ubuntu。</p>
<p>通过运行该命令，可以下载并安装Ubuntu的WSL子系统。WSL是一种在Windows中运行Linux的子系统，可以让用户在Windows环境中使用Linux命令行工具和开发工具，打破了操作系统间的壁垒，提高了开发效率和兼容性。需要注意的是，运行该命令需要管理员权限。</p>
</blockquote>
<p><strong>卸载：</strong></p>
<p><code>wsl --list --all</code>列出已安装的 WSL 分发版</p>
<p><code>wsl --unregister &lt;DistributionName&gt;</code>卸载指定的 WSL 子系统</p>
<p>请注意，卸载操作不会删除子系统的文件和数据。如果你想要删除与子系统相关的文件和数据，你可以手动删除 WSL 的安装目录。默认情况下，它位于 <code>C:\Users\你的用户名\AppData\Local\Packages</code> 目录下，并以子系统的名称命名。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527103144634.png"
                      class="" title="image-20230527103144634"
                >



<blockquote>
<p>设置开机启动 Hypervisor</p>
</blockquote>
<p><code>bcdedit /set hypervisorlaunchtype auto</code></p>
<p><strong>注意:要用管理员权限打开 PowerShell</strong></p>
<blockquote>
<p>设置默认使用版本2</p>
</blockquote>
<p><code>wsl.exe --set-default-version 2</code></p>
<blockquote>
<p>查看WSL是否正确</p>
</blockquote>
<p><code>wsl.exe --list --verbose</code></p>
<p>如下图，可以看到一个 Linux 系统， VERSION 是 2</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526104922907.png"
                      class="" title="image-20230526104922907"
                >



<blockquote>
<p>确保 BIOS 已开启虚拟化</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526105116820.png"
                      class="" title="image-20230526105116820"
                >



<blockquote>
<p>出现下图错误，点击链接安装最新版本的 WSL2</p>
</blockquote>
<p><code>https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526105353853.png"
                      class="" title="image-20230526105353853"
                >



<blockquote>
<p>镜像加速源</p>
</blockquote>
<table>
<thead>
<tr>
<th>镜像加速器</th>
<th>镜像加速器地址</th>
</tr>
</thead>
<tbody><tr>
<td>Docker 中国官方镜像</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://registry.docker-cn.com/" >https://registry.docker-cn.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>DaoCloud 镜像站</td>
<td><a class="link"   target="_blank" rel="noopener" href="http://f1361db2.m.daocloud.io/" >http://f1361db2.m.daocloud.io <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>Azure 中国镜像</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://dockerhub.azk8s.cn/" >https://dockerhub.azk8s.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>科大镜像站</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://docker.mirrors.ustc.edu.cn/" >https://docker.mirrors.ustc.edu.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>阿里云</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://ud6340vz.mirror.aliyuncs.com/" >https://ud6340vz.mirror.aliyuncs.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>七牛云</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://reg-mirror.qiniu.com/" >https://reg-mirror.qiniu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>网易云</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://hub-mirror.c.163.com/" >https://hub-mirror.c.163.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>腾讯云</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://mirror.ccs.tencentyun.com/" >https://mirror.ccs.tencentyun.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
</tbody></table>
<p><code>&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526105621213.png"
                      class="" title="image-20230526105621213"
                >

<p>在<code>ubuntu</code>系统中：编辑<code>/etc/docker/daemon.json</code>文件，添加下列标注：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230601144227352.png"
                      class="" title="image-20230601144227352"
                >



<h1 id="Docker-快速安装软件"><a href="#Docker-快速安装软件" class="headerlink" title="Docker 快速安装软件"></a>Docker 快速安装软件</h1><blockquote>
<p>直接安装的缺点</p>
</blockquote>
<ul>
<li>安装麻烦，可能有各种依赖，运行报错。例如：WordPress，ElasticSearch，Redis，ELK</li>
<li>可能对 Windows 并不友好，运行有各种兼容问题，软件只支持 Linux 上跑</li>
<li>不方便安装多版本软件，不能共存。</li>
<li>电脑安装了一堆软件，拖慢电脑速度。</li>
<li>不同系统和硬件，安装方式不一样</li>
</ul>
<blockquote>
<p>Docker安装的优点</p>
</blockquote>
<ul>
<li>一个命令就可以安装好，快速方便</li>
<li>有大量的镜像，可直接使用</li>
<li>没有系统兼容问题，Linux 专享软件也照样跑</li>
<li>支持软件多版本共存</li>
<li>用完就丢，不拖慢电脑速度</li>
<li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li>
</ul>
<blockquote>
<p>演示Docker安装Redis</p>
</blockquote>
<p>Redis 官网：<a class="link"   target="_blank" rel="noopener" href="https://redis.io/%E3%80%82Redis%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E7%9A%84%E5%BC%80%E6%BA%90%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%94%AF%E6%8C%81%E9%94%AE%E5%80%BC%EF%BC%88key-value%EF%BC%89%E5%AD%98%E5%82%A8%EF%BC%8C%E5%B8%B8%E7%94%A8%E4%BA%8E%E7%BC%93%E5%AD%98%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%81%E6%8E%92%E8%A1%8C%E6%A6%9C%E3%80%81%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AD%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%AA%E6%9C%89%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%B2%A1%E6%9C%89" >https://redis.io/。Redis是一个快速的开源内存数据库系统，支持键值（key-value）存储，常用于缓存、消息队列、排行榜、计数器等应用场景。官网下载安装教程只有源码安装方式，没有 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Windows 版本，安装不方便。</p>
<p>Docker 官方镜像仓库查找 Redis ：<a class="link"   target="_blank" rel="noopener" href="https://hub.docker.com/" >https://hub.docker.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526131919282.png"
                      class="" title="image-20230526131919282"
                >



<p><code>docker run -d -p 6379:6379 --name redis redis:latest</code>：</p>
<ul>
<li><code>docker run</code> 是 Docker 启动容器的命令。</li>
<li><code>-d</code> 表示在后台运行容器。</li>
<li><code>-p 6379:6379</code> 表示将宿主机（Host）的 6379 端口映射到容器的 6379 端口，即通过主机的 6379 端口来访问 Redis 容器的 6379 端口。</li>
<li><code>--name redis</code> 表示为容器指定名称为 redis。</li>
<li><code>redis:latest</code> 则是 Redis 镜像的名称和版本号。其中，Redis 是镜像的名称，latest 是版本标签，表示使用 Redis 最新版本的镜像运行容器。</li>
</ul>
<p>在 Docker 中启动 Redis 容器，并映射宿主机的 6379 端口到 Redis 容器的 6379 端口上，使得在外部应用程序可以通过这个端口与 Redis 交互。</p>
<p>命令参考：<code>https://docs.docker.com/engine/reference/commandline/run/</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526132857569.png"
                      class="" title="image-20230526132857569"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526132951992.png"
                      class="" title="image-20230526132951992"
                >



<blockquote>
<p>安装WordPress</p>
</blockquote>
<p>WordPress是一种自由和开源的内容管理系统（CMS），它以PHP和MySQL为基础，是目前应用最广泛的网站管理软件之一。它提供用户友好的界面，使得任何人都可以创建和管理包含文章、图片、音频和视频的网站，而无需编写代码。</p>
<p><strong>方式一</strong>：不推荐，因为wordpress需要数据库等配置</p>
<p><code>docker run --name some-wordpress --network some-network -d wordpress</code></p>
<ul>
<li><code>-d</code>：表示在后台运行</li>
<li><code>--name</code>：容器名称</li>
<li><code>wordpress</code>：镜像名称</li>
</ul>
<p><strong>方式二：</strong></p>
<p>1.新建<code>docker-compose.yml</code>文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526135407657.png"
                      class="" title="image-20230526135407657"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526140156470.png"
                      class="" title="image-20230526140156470"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526140256997.png"
                      class="" title="image-20230526140256997"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526140426429.png"
                      class="" title="image-20230526140426429"
                >



<blockquote>
<p>安装ELK</p>
</blockquote>
<p>ELK 组合可以实现日志的集中式管理、搜索、分析和可视化。它广泛应用于日志分析、系统监控、安全分析等领域，提供了强大的功能和灵活的扩展性，成为许多组织和企业进行日志处理和分析的首选解决方案之一。</p>
<blockquote>
<p>更多相关命令</p>
</blockquote>
<h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p>
<h1 id="制作自己的镜像"><a href="#制作自己的镜像" class="headerlink" title="制作自己的镜像"></a>制作自己的镜像</h1><h2 id="DockerFile文件"><a href="#DockerFile文件" class="headerlink" title="DockerFile文件"></a>DockerFile文件</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/docker%E6%B5%81%E7%A8%8B.png"
                      class=""
                >

<h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><p>注意：</p>
<ul>
<li>每个 DockerFile 的保留字（指令），都必须是大写的</li>
<li>DockerFile 脚本执行是按照顺序执行的</li>
<li><code># </code>表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层，并提交</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526150541837.png"
                      class="" title="image-20230526150541837"
                >



<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li><p>FROM：基础的镜像，一切都是从这里开始的</p>
</li>
<li><p>MAINTAINER：指明镜像是谁写的，写下自己的姓名和邮箱</p>
</li>
<li><p>RUN：镜像构建的时候需要运行的命令</p>
</li>
<li><p>ADD：<code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<ul>
<li>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。</li>
<li>但下载后的文件权限默认是600；可能需要解压缩等操作额外需要增加<code>RUN</code>层进行调整。所有这个功能并不实用</li>
<li>最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</li>
</ul>
</li>
<li><p>WORKDIR：镜像的工作目录</p>
</li>
<li><p>VOLUME：挂载目录</p>
</li>
<li><p>EXPOSE：暴露端口 和<code> -p</code> 是一个效果</p>
</li>
<li><p><strong>CMD：指定这个容器启动的时候执行的命令，只会是最优一个指令进行生效，会被替代</strong></p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
</li>
<li><p><strong>ENTRYPOINT：指定这个容器启动的时候执行的命令，可以追加</strong></p>
<ul>
<li>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，<strong>即<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code></strong></li>
</ul>
</li>
<li><p>ONBUILD：<code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
</li>
<li><p>COPY：与 ADD 类似，此命令是将文件拷贝到镜像中</p>
<ul>
<li><p>格式：<code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p>
</li>
<li><p>目标路径指的是host主机的文件路径</p>
</li>
<li><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
</li>
<li><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p>
</li>
<li><pre><code class="bash">COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/			#文件和目录的权限和所有者会被修改为 bin 用户和用户组的默认 UID 和 GID。UID和GID是Linux/Unix系统中用于标识用户和用户组的唯一数字ID。
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ENV：构建的时候设置环境变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 镜像制作</span><br><span class="line"></span><br><span class="line">官方的`ubuntu`是阉割版本的，很多工具和命令都是不支持的</span><br><span class="line"></span><br><span class="line">`docker run -it ubuntu:18.04`：</span><br><span class="line"></span><br><span class="line">- `-i`（--interactive）：保持标准输入（stdin）打开，允许你与容器进行交互。</span><br><span class="line">- `-t`（--tty）：为容器分配一个伪终端（pseudo-TTY），使得你可以在容器内部使用终</span><br><span class="line"></span><br><span class="line">{% asset_img "image-20230526162447318.png" "image-20230526162447318" %}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; DockerFile书写流程</span><br><span class="line"></span><br><span class="line">```dockerfile</span><br><span class="line"></span><br><span class="line">FROM ubuntu													#注意，需要安装基本镜像才能使用DockerFile进行自定义镜像构建</span><br><span class="line"></span><br><span class="line">RUN apt-get update										#必须包含</span><br><span class="line"></span><br><span class="line">RUN  apt-get install -y vim								#-y标志用于在命令行中自动确认或接受默认选项，而不需要用户进行交互确认。</span><br><span class="line"></span><br><span class="line">RUN  apt-get install -y net-tools	</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local				</span><br><span class="line">WORKDIR $MYPATH					</span><br><span class="line"></span><br><span class="line">EXPOSE 8888						</span><br><span class="line"></span><br><span class="line">CMD echo &quot;----- end -----&quot;							#执行echo命令</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>开始构建</p>
</blockquote>
<p><code>docker build -f dockerfile -t airubuntu:v1 .</code></p>
<ul>
<li><code>docker build</code>: 这是 Docker 命令，用于构建 Docker 镜像。</li>
<li><code>-f dockerfile</code>: 这是 <code>-f</code> 选项，用于指定要使用的 Dockerfile 文件的名称或路径。在这个例子中，指定的 Dockerfile 文件为 <code>dockerfile</code>。</li>
<li><code>-t airubuntu</code>: 这是 <code>-t</code> 选项，用于为构建的镜像指定一个标签（tag）。在这个例子中，镜像将被标记为 <code>airubuntu</code>。</li>
<li><code>v1</code>表示版本</li>
<li><code>.</code>: 这个点表示 Docker 构建上下文的路径。它指定了要构建镜像时使用的上下文路径，该路径中包含了构建镜像所需的文件和目录。在这个例子中，上下文路径为当前目录。</li>
</ul>
<blockquote>
<p>上下文路径可以是一个文件夹的路径，也可以是一个压缩文件（例如.tar、.tar.gz、.tar.bz2）的路径。当指定的上下文路径是一个文件夹时，Docker 引擎将会递归地复制该文件夹中的所有文件和子文件夹到镜像中。当指定的上下文路径是一个压缩文件时，Docker 引擎会将其解压缩并使用解压后的内容作为上下文。</p>
<p>在构建镜像时，上下文路径中的文件和目录可以在 Dockerfile 中使用相对路径来引用和操作。</p>
</blockquote>
<blockquote>
<p>在 Dockerfile 中使用标签（tag）可以给构建的镜像<strong>添加一个可识别和标识的标签，以便在后续操作中引用该镜像</strong>。标签可以用于标识镜像的版本、用途、环境等信息，便于管理和区分不同的镜像。</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526153959896.png"
                      class="" title="image-20230526153959896"
                >

<p><strong>注意：</strong>如果不在 DockerFile 中写入 <code>apt-get update </code>更新源，会出现下面这个问题</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526182110494.png"
                      class="" title="image-20230526182110494"
                >



<blockquote>
<p>验证结果</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526182421354.png"
                      class="" title="image-20230526182421354"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526185317735.png"
                      class="" title="image-20230526185317735"
                >



<blockquote>
<p>CMD和ENTRYPOINT的区别</p>
</blockquote>
<ul>
<li><p>CMD：指定这个容器启动的时候执行的命令，只会是最优一个指令进行生效，<strong>会被替代</strong></p>
</li>
<li><p>ENTRYPOINT：指定这个容器启动的时候执行的命令，<strong>可以追加</strong></p>
</li>
</ul>
<p><strong>CMD</strong></p>
<p>写一个简单的 DockerFile 文件名为 dockerfile-cmd</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> airubuntu</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]</span></span><br></pre></td></tr></table></figure></div>

<p>构建镜像并启动</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526202341404.png"
                      class="" title="image-20230526202341404"
                >

<p>启动容器时追加命令<code>docker run -it dockerfile-cmd -l</code>报错：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526202806979.png"
                      class="" title="image-20230526202806979"
                >

<p>原因如下：</p>
<p>使用 <code>CMD</code>指令是（例如我们的例子是 <code>ls -a</code>），我们在启动容器的时候，后面追加的命令（<code>-l</code>）会把 <code>ls -a</code>替换掉，由于<code>-l</code>不是一个命令，因此报错</p>
<p><strong>ENTRYPOINT</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM airubuntu</span><br><span class="line">ENTRYPOINT[&quot;ls&quot;,&quot;-a&quot;]</span><br></pre></td></tr></table></figure></div>

<p>构建镜像并启动</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526203016899.png"
                      class="" title="image-20230526203016899"
                >

<p>可以看出使用 <code>ENTRYPOINT</code>是可以在后面追加参数的，使用<code>CMD</code>若指令后面追加参数，那么会覆盖<code>CMD</code>指定的指令</p>
<blockquote>
<p>发布镜像</p>
</blockquote>
<p>1、登录dockerhub</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker login -u xxxx用户名</span></span><br><span class="line">Password:</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/<span class="comment">#credentials-store</span></span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure></div>



<p>2、修改镜像</p>
<p><code>docker tag 镜像id docker用户/镜像名称:版本</code></p>
<p>3、推送镜像到仓库</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526204241163.png"
                      class="" title="image-20230526204241163"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526204407002.png"
                      class="" title="image-20230526204407002"
                >



<blockquote>
<p>补充：docker流程</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526204637050.png"
                      class="" title="image-20230526204637050"
                >

<h3 id="导入与导出"><a href="#导入与导出" class="headerlink" title="导入与导出"></a>导入与导出</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。<strong>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也比较大</strong>。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<blockquote>
<p>导出容器</p>
</blockquote>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令，将导出容器快照到本地文件。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> 5c6be7e3d37b0c07c61bec057a4f1a9d35f329cd1d0615fba3527384ff1b7128 &gt; ubuntu_import.tar</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530160628154.png"
                      class="" title="image-20230530160628154"
                >

<blockquote>
<p>导入容器快照</p>
</blockquote>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ubuntu.tar | docker import - ubuntu_import:v1.0		<span class="comment">#使用-表示从标准输入流中读取数据。这条命令使用cat命令将文件myimage.tar的内容读取到标准输出流中，然后通过管道将内容传递给docker import命令，最终创建名为test/ubuntu、版本号为v1.0的新镜像。</span></span><br></pre></td></tr></table></figure></div>



<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：导入的容器是镜像</strong></p>
<blockquote>
<p>启动导入的容器</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --name 新建容器名 /bin/bash			<span class="comment">#以bash启动容器</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">镜像导出</span></span><br><span class="line">docker save -o xxx.tar 镜像：版本号	#-o, --output string   Write to a file, instead of STDOUT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">镜像导入：</span></span><br><span class="line">docker load -i tar包名称.tar			#指定导入的文件，代替 STDIN</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>





<h1 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h1><p><strong>现存问题：</strong></p>
<ul>
<li>使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新<code>build</code>和<code>run</code>，很是麻烦</li>
<li>容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了</li>
<li>可以通过目录挂载解决上述问题</li>
</ul>
<blockquote>
<p>挂载方式</p>
</blockquote>
<ul>
<li><p><code>bind mount</code> 可以存储在 Docker Host 文件系统的任何位置，它们甚至可能是重要的系统文件或目录，非 Docker 的进程或者 Docker 容器可能随时对其进行修改，存在潜在的安全风险。可多容器共享。</p>
</li>
<li><p><code>volume</code> Volumes 存储在 Docker Host 文件系统的一个路径下，这个路径是由 Docker 来进行管理，路径默认是 <code>/var/lib/docker/volumes/</code>，非 Docker 的进程不能去修改这个路径下面的文件，所以说 Volumes 是持久存储数据最好的一种方式。可多容器共享。</p>
</li>
<li><p><code>tmpfs mount</code> 只存储在 Docker Host 的系统内存中，不会写入到系统的文件系统中，不会持久存储。不可多容器共享。</p>
</li>
</ul>
<p><strong>注意：<code>Docker host</code>文件系统就是是指宿主机上的文件系统。</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230526210224424.png"
                      class="" title="image-20230526210224424"
                >



<blockquote>
<p>挂载演示</p>
</blockquote>
<p><code>bind mount -v 本地绝对路径</code></p>
<p><code>volume -v 本机绝对路径:容器绝对路径</code></p>
<p>示例：<br><code>docker run -p 8080:8080 --name test-hello -v D:/code:/app -d test:v1</code></p>
<p><strong>注意：</strong>挂载后，容器里的代码已替换为本机的代码，如果代码目录没有<code>node_modules</code>目录，需要在代码目录执行下<code>npm install --registry=https://registry.npm.taobao.org</code>确保依赖库都已经安装，否则可能会提示“Error: Cannot find module ‘koa’”<br>如果电脑没有安装 <a class="link"   target="_blank" rel="noopener" href="https://nodejs.org/en/" >nodejs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，需要安装一下才能执行上面的命令。</p>
<h2 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h2><blockquote>
<p>-v语法</p>
</blockquote>
<p>它有三部分组成，使用:进行分割，这些字段必须以正确的顺序排列</p>
<ul>
<li>第一个字段是 Docker Host 上的一个文件或者目录。</li>
<li>第二个字段是将要挂载到容器上的一个文件或者目录。</li>
<li>第三个字段是可选的，用来增加一些附加选项，比如 ro.</li>
</ul>
<blockquote>
<p>–mount语法</p>
</blockquote>
<p>由多个键值对组成，以逗号分隔。<strong>下列的key选其一，value类似</strong></p>
<table>
<thead>
<tr>
<th align="center">key</th>
<th align="center">value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">type</td>
<td align="center">bind, volume, or tmpfs</td>
</tr>
<tr>
<td align="center">source&#x2F;src</td>
<td align="center">Docker Host上的一个目录或者文件</td>
</tr>
<tr>
<td align="center">destination&#x2F;dst&#x2F;target</td>
<td align="center">被挂载容器上的一个目录或者文件</td>
</tr>
<tr>
<td align="center">readonly</td>
<td align="center">挂载为只读</td>
</tr>
<tr>
<td align="center">option</td>
<td align="center">其它选项</td>
</tr>
</tbody></table>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>将 Docker Host 的目录<code>D:\study\docker\bind_mount</code>挂载到 nginx 容器的<code>usr/local/bindtest</code>。<code>D:\study\docker\bind_mount</code>路径下有<code>test.txt</code>文件，内容为<code>this is bind test</code></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name bindtest --mount type=bind,source=D:\study\docker\bind_mount,target=/usr/local/bindtest bindtest</span><br></pre></td></tr></table></figure></div>

<p>使用命令<code>docker inspect 容器名</code>来查看挂载是否正确挂载。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527152727531.png"
                      class="" title="image-20230527152727531"
                >

<p>进入<code>bindtest</code>容器查看<code>test.txt</code>文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527153130778.png"
                      class="" title="image-20230527153130778"
                >

<p>将容器销毁掉，查看创建的文件是否存在。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop bindtest</span><br><span class="line">docker rm bindtest</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527153552080.png"
                      class="" title="image-20230527153552080"
                >



<blockquote>
<p>只读挂载</p>
</blockquote>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -it -d --name bindtest --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=D:\study\docker\bind_mount,target=/usr/local/bindtest，<span class="built_in">readonly</span> bindtest</span></span><br></pre></td></tr></table></figure></div>

<p>查看挂载详情，是否为只读模式。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527153858425.png"
                      class="" title="image-20230527153858425"
                >

<p>readonly 设置了只读权限，在容器中是无法对 bind mount 数据进行修改的。只有 host 有权修改数据，提高了安全性。</p>
<blockquote>
<p>单文件挂载</p>
</blockquote>
<p>单文件挂载 除了制定目录外，我们也可以指定单个文件进行覆盖，如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name bindtestsingle --mount type=bind,source=D:\study\docker\bind_mount\single_mount.txt,target=/usr/local/single_mount.txt bindtest</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：本地路径与容器路径都要指定文件名称</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527154435772.png"
                      class="" title="image-20230527154435772"
                >



<h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><p>Volume 完全由 Docker 来进行管理，比如 volume 的创建，可以使用命令 <code>docker volume create volume</code>名称来简单的创建一个 volume，当容器或者服务创建的时候，Docker 也可以自动的创建一个 volume。 </p>
<p><strong>注意：volume不是相对镜像的，而是与容器实例相关联。在创建 volume 时，不需要直接指定容器。</strong>你可以在创建容器时，通过 <code>-v</code> 或 <code>--volume</code> 参数来指定要挂载的 volume，并将其关联到容器内部的指定路径。这样，容器在运行时会自动创建该 volume，并将其挂载到指定的路径上。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PS D:\study\docker&gt; docker volume create volumetest				#创建volume</span><br><span class="line">testVolume</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS D:\study\docker&gt; docker volume ls										#列出volumes</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     1f1825473131668d6210a15161235830ce3794fa26334fe91b25cb3c3031e8b3</span><br><span class="line">local     docker_db</span><br><span class="line">local     docker_wordpress</span><br><span class="line">local     testVolume</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS D:\study\docker&gt; docker volume inspect volumetest		#查看volume详细信息</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2023-05-26T14:05:12Z&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/volumetest/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;volumetest&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS D:\study\docker&gt; docker volume rm testVolume			#删除volume</span><br><span class="line">testVolume</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>使用无数据的volume创建容器</p>
</blockquote>
<p>上述的volume中是没有数据的，可以使用<code>ll /var/lib/docker/volumes/volumetest/_data</code>查看</p>
<p>注意：<code>/var/lib/docker/volumes/volumetest/_data</code> 实际上是 WSL 文件系统中的路径。<strong>Windows 宿主机无法直接访问 WSL 的文件系统路径。</strong>因此，在 Windows 上使用 Windows 资源管理器或其他工具浏览到 <code>/var/lib/docker/volumes/volumetest/_data</code> 是不可能的。需要使用 WSL 终端或 WSL 文件共享来访问 Volume 挂载点的内容。</p>
<blockquote>
<ul>
<li><code>docker exec -it volumetest bash</code>：这个命令是在已经运行的容器中执行一个新的进程。这意味着容器必须已经在运行状态，以便与容器进行交互或执行特定任务。</li>
<li><code>docker run -it volumetest</code>：这个命令是启动一个新的容器，并进入交互模式。这意味着每次运行这个命令时都会创建一个全新的容器实例。在这个例子中，你将进入新容器的默认进程（可能是容器中的默认 shell）。</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建容器挂载并启动：</span></span><br><span class="line">docker run -d -it --name volumetest --mount type=volume,source=volumetest,target=/usr/share/volumetest volumetest</span><br></pre></td></tr></table></figure></div>

<p><code>docker inspect volumetest</code>查看容器的挂载详情</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527145122234.png"
                      class="" title="image-20230527145122234"
                >

<p>在<code>volumetest</code>容器中新建<code>test.txt</code>文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527145359274.png"
                      class="" title="image-20230527145359274"
                >



<blockquote>
<p>使用有数据volume创建容器</p>
</blockquote>
<p>接着上个 volume 进行测试，宿主机已经存在文件<code>test.txt</code>，更改里面的内容为<code>hello this is test........</code>。确认好 volume 之后，启动容器。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it  -p 80:80  --name volumetest1 --mount source=volumetest,target=/usr/local/volumetest volumetest</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527145535023.png"
                      class="" title="image-20230527145535023"
                >

<p>可以看到，当 volume 里面有数据的时候，容器内的数据就被 volume 覆盖了，同样的，删除容器之后，volume 里面的数据会依然存在的。</p>
<blockquote>
<p>不提前创建volume启动容器</p>
</blockquote>
<p>之前的情况都提前创建好 volume 进行挂载，这次不提前创建，直接指定，看看会出现什么情况。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name volumetest2 --mount type=volume,source=volumetest2,target=/usr/local/volumetest2 volumetest</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527145947209.png"
                      class="" title="image-20230527145947209"
                >

<p>成功创建了<code>volumetest2</code>，使用名称查看一下 volume 的情况。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527150027978.png"
                      class="" title="image-20230527150027978"
                >

<p>使用<code>docker inspect volumetest2</code>查看挂载详情。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527150124754.png"
                      class="" title="image-20230527150124754"
                >



<p><strong>如果使用 bind mount，源目录必须存在，不然docker 会报错，然而使用 volume，如果源不存在，docker 会自动进行创建。</strong></p>
<p>这是因为 bind mount 挂载的路径并不是 docker 进行管理的，没有权限随便创建目录， volume 是 docker 进行管理的，它可以在自己的存储目录下面创建 volume。当我们想把容器内的数据导出来时，使用这种方式非常方便。</p>
<blockquote>
<p>只读模式挂载volume</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name volumetestreadonly --mount type=volume,source=volumetest,target=/usr/local/volumetestreadonly,readonly volumetest</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527150939246.png"
                      class="" title="image-20230527150939246"
                >

<p><code>docker inspect volumetestreadonly</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527151018737.png"
                      class="" title="image-20230527151018737"
                >

<p><code>vim test.txt</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527151203025.png"
                      class="" title="image-20230527151203025"
                >

<p>到这里简单对比一下 bind mount 和 volume 的区别。</p>
<table>
<thead>
<tr>
<th align="center">区别</th>
<th align="center">bind mount</th>
<th align="center">volume</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">source位置</td>
<td align="center">可以任意指定</td>
<td align="center">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;….</td>
<td></td>
</tr>
<tr>
<td align="center">source为空</td>
<td align="center">覆盖掉容器的内容</td>
<td align="center">容器内数据复制到volume</td>
<td></td>
</tr>
<tr>
<td align="center">是否支持单个文件</td>
<td align="center">支持</td>
<td align="center">不支持，只能是目录</td>
<td></td>
</tr>
<tr>
<td align="center">权限控制</td>
<td align="center">读写或者只读</td>
<td align="center">读写或者只读</td>
<td></td>
</tr>
<tr>
<td align="center">移植性</td>
<td align="center">弱,与hostpath 绑定</td>
<td align="center">强，无需指定hostpath</td>
<td></td>
</tr>
</tbody></table>
<h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>tmpfs 不在磁盘上持久存储，也不在 Docker Host 容器里面存储，他存储在 host 的内存中，它可以在容器的整个生命周期内被容器所使用。</p>
<blockquote>
<p>使用场景</p>
</blockquote>
<p>当不需要持久保留数据在 host 或容器内。这可能是出于安全原因，或者是提升容器的性能，比如程序需要写入很多不需要存储的状态数据时，就会使用 tmpfs。</p>
<blockquote>
<p>使用语法</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name tmpfstest --mount type=tmpfs,target=/usr/local/tmpfstest</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527155909620.png"
                      class="" title="image-20230527155909620"
                >



<h1 id="多容器通信"><a href="#多容器通信" class="headerlink" title="多容器通信"></a>多容器通信</h1><h2 id="Docker网络模式"><a href="#Docker网络模式" class="headerlink" title="Docker网络模式"></a>Docker网络模式</h2><ul>
<li>bridge</li>
<li>host</li>
<li>container模式</li>
<li>none</li>
<li>用户自定义模式（bridge、overlay、macvlan）</li>
</ul>
<p>Docker的网络模式大概可以分为5种类型。安装完 Docker，宿主机默认会创建三个网络，分别是bridge网络，host网络，none网络，可以使用docker network ls命令查看。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@tuling ~]$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">99fe18249fa6        bridge              bridge              local</span><br><span class="line">e60bf8b6ed5b        host                host                local</span><br><span class="line">3a142d398cf9        none                null                local</span><br></pre></td></tr></table></figure></div>



<h3 id="bridge方式（默认）"><a href="#bridge方式（默认）" class="headerlink" title="bridge方式（默认）"></a>bridge方式（默认）</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name network_none - network_bridge:latest		#创建容器</span><br></pre></td></tr></table></figure></div>

<p>容器的默认网络模式，docker在安装时会创建一个名为docker0的Linux bridge，在不指定–network的情况下，创建的容器都会默认挂到<code>docker0</code>上面。bridge模式为容器创建独立的网络栈，保证容器内的进程使用独立的网络环境，使容器之间，容器和docker host之间实现网络隔离。如下图：<strong>etho0是容器默认创建的。</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527163209810.png"
                      class="" title="image-20230527163209810"
                >

<p>Docker主机的IP可以打开<code>WSL</code>命令行查看，再通过容器ping</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230527181807514.png"
                      class="" title="image-20230527181807514"
                >



<h3 id="none方式"><a href="#none方式" class="headerlink" title="none方式"></a>none方式</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name network_none --net=&quot;none&quot; network_none:latest		#创建容器</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529091642584.png"
                      class="" title="image-20230529091642584"
                >

<p>这种方式将网络创建的责任完全交给用户。 可以实现更加灵活复杂的网络。 另外这种容器可以可以通过link容器实现通信。</p>
<h3 id="host方式"><a href="#host方式" class="headerlink" title="host方式"></a>host方式</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name work_host --net=&quot;host&quot; network</span><br></pre></td></tr></table></figure></div>

<p>指定方法：–net&#x3D;”host” <strong>使用host模式的容器可以直接使用docker host的IP地址与外界通信</strong>，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。</p>
<h3 id="container复用方式"><a href="#container复用方式" class="headerlink" title="container复用方式"></a>container复用方式</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name network_container --net=&quot;container:af09470962b0be7240bb834290194b7510139c077684e34052c862a9ba367ba4&quot; network</span><br></pre></td></tr></table></figure></div>



<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529094924865.png"
                      class="" title="image-20230529094924865"
                >

<p>例子可以看出来，两者的网络完全相同。这样的好处是如<strong>果部署一个应用，可以将应用的不同组件部署在不同的容器中，对外可以看上出是一个整体</strong></p>
<h3 id="user-defined模式"><a href="#user-defined模式" class="headerlink" title="user-defined模式"></a>user-defined模式</h3><p>用户自定义模式主要可选的有三种网络驱动：bridge、overlay、macvlan。bridge驱动用于创建类似于前面提到的bridge网络;overlay和macvlan驱动用于创建跨主机的网络、IP等。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver drivername name		#在Docker启动前创建网络。</span><br></pre></td></tr></table></figure></div>

<ul>
<li>drivername - 网络驱动程序名称。</li>
<li>name - 网络名称。</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge mybridge</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529095511093.png"
                      class="" title="image-20230529095511093"
                >

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name network_userdefined --net=&quot;mybridge&quot; network</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect mybridge			#发现一个容器已经链接到网桥。</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529095939846.png"
                      class="" title="image-20230529095939846"
                >

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect bridge work_host		#连接网络</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529141020895.png"
                      class="" title="image-20230529141020895"
                >

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect mybridge network_userdefined		#断开网络</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529141255019.png"
                      class="" title="image-20230529141255019"
                >

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm mybridge		#移除网络</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：如果通过某个自定义网络模式创建了容器，则该网络模式无法删除。</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529141600377.png"
                      class="" title="image-20230529141600377"
                >



<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name network_port_1 -p 49155:5000 network</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529103529387.png"
                      class="" title="image-20230529103529387"
                >



<h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，默认会绑定本地所有接口上的所有地址。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure></div>



<h3 id="指定端口映射到指定地址"><a href="#指定端口映射到指定地址" class="headerlink" title="指定端口映射到指定地址"></a>指定端口映射到指定地址</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py		<span class="comment">#该IP地址的作用是限制访问该容器的网络接口为主机的回环地址，只能通过主机本身访问该容器的应用程序。</span></span></span><br></pre></td></tr></table></figure></div>



<h3 id="任意端口映射到指定地址"><a href="#任意端口映射到指定地址" class="headerlink" title="任意端口映射到指定地址"></a>任意端口映射到指定地址</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，<strong>本地主机会自动分配一个端口</strong>。</p>
<h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529105628572.png"
                      class="" title="image-20230529105628572"
                >

<p>注意：</p>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li>
<li><code>-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>
<p>例如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -p 3000:80 \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure></div>



<h2 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h2><h4 id="docker网络通信"><a href="#docker网络通信" class="headerlink" title="docker网络通信"></a>docker网络通信</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name netconn1 baseubuntu</span><br><span class="line">docker run -dit --name netconn2 baseubuntu</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529144908767.png"
                      class="" title="image-20230529144908767"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529145018617.png"
                      class="" title="image-20230529145018617"
                >

<p>从结果得知两个属于同一个网络驱动的容器是可以进行网络通信的，但是 IP 地址可能是不固定的，有被更改的情况发生</p>
<p><strong>注意：无法使用容器名称进行网络通信</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529145234897.png"
                      class="" title="image-20230529145234897"
                >



<h4 id="自定义网络通信"><a href="#自定义网络通信" class="headerlink" title="自定义网络通信"></a>自定义网络通信</h4><p>　　从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称通信。但是使用 Docker DNS 有个限制：<strong>只能在 user-defined 网络中使用</strong>。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以需要自定义网络。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name netconn_userdefined1 --net mybridge baseubuntu</span><br><span class="line">docker run -dit --name netconn_userdefined2 --net mybridge baseubuntu</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529145638397.png"
                      class="" title="image-20230529145638397"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529145836844.png"
                      class="" title="image-20230529145836844"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529145918330.png"
                      class="" title="image-20230529145918330"
                >

<p>　从结果得知两个属于同一个自定义网络的容器是可以进行网络通信的，<strong>并且可以使用容器名称进行网络通信。</strong></p>
<h4 id="docker与自定义网络通信"><a href="#docker与自定义网络通信" class="headerlink" title="docker与自定义网络通信"></a>docker与自定义网络通信</h4><p>将 <code>bridge</code> 网络下的容器连接至新的 <code>custom_network</code> 网络即可</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect mybridge  netconn1</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529150412262.png"
                      class="" title="image-20230529150412262"
                >



<h4 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h4><p>自定义配置容器的主机名和 DNS：利用虚拟文件来挂载容器的 3 个相关配置文件</p>
<p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">/dev/sdd on /etc/resolv.conf <span class="built_in">type</span> ext4 (rw,relatime,discard,errors=remount-ro,data=ordered)</span><br><span class="line">/dev/sdd on /etc/hostname <span class="built_in">type</span> ext4 (rw,relatime,discard,errors=remount-ro,data=ordered)</span><br><span class="line">/dev/sdd on /etc/hosts <span class="built_in">type</span> ext4 (rw,relatime,discard,errors=remount-ro,data=ordered)</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>单个容器配置</p>
</blockquote>
<p>容器中的 <code>/etc/resolv.conf</code>文件内容如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 127.0.0.11</span><br><span class="line">options ndots:0</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>nameserver 127.0.0.11</code>: 这一行指定了容器内部使用的DNS服务器的IP地址。</li>
<li><code>options ndots:0</code>: 这一行设置了DNS解析的选项。<code>ndots:0</code>表示当进行主机名解析时，不要追加搜索域名后缀。</li>
</ul>
<blockquote>
<p>多容器配置</p>
</blockquote>
<p>宿主机上<code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用在容器中使用<code>cat /etc/resolv.conf</code>命令查看文件内容来证明其生效。</p>
<blockquote>
<p>手动配置</p>
</blockquote>
<p>使用 <code>docker run</code> 命令启动容器时加入如下参数：</p>
<p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p>
<p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p>
<p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p>
<p><strong>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</strong></p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。<code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。<code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。<code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<h2 id="安装有卸载"><a href="#安装有卸载" class="headerlink" title="安装有卸载"></a>安装有卸载</h2><p><code>Compose</code> 支持 Linux、macOS、Windows 10 三大平台。<code>Compose</code> 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line"></span><br><span class="line">docker-compose version 1.25.5, build 4667896b</span><br></pre></td></tr></table></figure></div>

<p>Linux 系统请使用以下介绍的方法安装。</p>
<h3 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h3><p>在 Linux 上的也安装十分简单，从 <a class="link"   target="_blank" rel="noopener" href="https://github.com/docker/compose/releases" >官方 GitHub Release <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 处直接下载编译好的二进制文件即可。</p>
<p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose		<span class="comment">#从而可以直接在命令行中运行 docker-compose 命令。</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>x86_64（也称为x64、AMD64或Intel 64）和ARM都是处理器架构，用于构建不同类型的计算设备和系统。它们之间的主要区别在于硬件架构和指令集。</p>
<ol>
<li>硬件架构：<ul>
<li>x86_64：x86_64是基于Intel的x86架构的64位扩展，广泛应用于桌面、服务器和大型计算机等设备。</li>
<li>ARM：ARM是一种基于RISC（Reduced Instruction Set Computing）的处理器架构，常见于移动设备、嵌入式系统和物联网等领域。</li>
</ul>
</li>
<li>指令集：<ul>
<li>x86_64：x86_64使用复杂的CISC（Complex Instruction Set Computing）指令集，具有较高的指令集数量和复杂度。</li>
<li>ARM：ARM使用精简的RISC指令集，指令数量相对较少，更简洁、高效。</li>
</ul>
</li>
</ol>
<p>在Linux操作系统中，x86_64和ARM架构的系统会有一些差异，例如：</p>
<ul>
<li>二进制可执行文件：x86_64和ARM使用不同的指令集，因此二进制可执行文件通常是特定于架构的。<strong>一个为x86_64编译的可执行文件不能直接在ARM架构上运行，反之亦然。</strong></li>
<li>软件包和库：软件包和库通常会提供特定架构的版本，用户需要选择适合其硬件架构的版本进行安装和使用。</li>
<li>内核和驱动程序：不同的架构可能需要特定的内核和驱动程序来支持硬件设备。</li>
</ul>
</blockquote>
<h3 id="PIP安装"><a href="#PIP安装" class="headerlink" title="PIP安装"></a>PIP安装</h3><p><code>x86_64</code> 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 <code>ARM</code> (例如，树莓派)，再使用 <code>pip</code> 安装。</p>
<p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</p>
<p>执行安装命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install -U docker-compose</span><br></pre></td></tr></table></figure></div>

<p>可以看到类似如下输出，说明安装成功。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting docker-compose</span><br><span class="line">  Downloading docker-compose-1.25.5.tar.gz (149kB): 149kB downloaded</span><br><span class="line">...</span><br><span class="line">Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress</span><br></pre></td></tr></table></figure></div>



<h3 id="bash-补全命令"><a href="#bash-补全命令" class="headerlink" title="bash 补全命令"></a>bash 补全命令</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose			<span class="comment">#在使用 Docker Compose 命令时获得自动补全支持。</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>curl -L &lt;URL&gt;</code>: 使用 <code>curl</code> 命令从指定的 URL 下载文件。**<code>-L</code> 标志用于跟随重定向。**</li>
<li><code>https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose</code>: 是要下载的文件的 URL 地址，这是 Docker Compose 的自动补全脚本所在的地址。</li>
<li><code>&gt;</code>: 重定向操作符，将命令输出的结果重定向到文件中。</li>
<li><code>/etc/bash_completion.d/docker-compose</code>: 目标文件的路径，即将下载的脚本文件保存到 <code>/etc/bash_completion.d</code> 目录下，并命名为 <code>docker-compose</code>。</li>
</ul>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></div>

<p>如果是通过 <code>pip</code> 安装的，则执行如下命令即可删除。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip uninstall docker-compose</span><br></pre></td></tr></table></figure></div>



<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>和docker 的Dockerfile类似文件，docker-compose使用 YAML 文件对容器进行管理。首先介绍几个术语。</p>
<ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<h3 id="YAML文件"><a href="#YAML文件" class="headerlink" title="YAML文件"></a>YAML文件</h3><p>YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。使用空白，缩进，分行组织数据，从而使得表示更加简洁易读.</p>
<ul>
<li>大小写敏感</li>
<li>缩进表示层级关系</li>
<li>缩进空格数不重要，相同层级左侧对齐即可。（<strong>不允许使用 tab 缩进！</strong>）</li>
<li>连续的项目（如：数组元素、集合元素）通过减号“-”来表示</li>
<li>map结构里面的键值对（key&#x2F;value）用冒号“:”来分割</li>
<li>使用#表示注释</li>
</ul>
<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p>
<h3 id="web-应用"><a href="#web-应用" class="headerlink" title="web 应用"></a>web 应用</h3><p>新建文件夹，在该目录中编写 <code>app.py</code> 文件</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hit_count</span>():</span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>Dockerfile</p>
</blockquote>
<p>编写 <code>Dockerfile</code> 文件，内容为</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP app.py														<span class="comment">#设置环境变量 FLASK_APP 的值为 app.py，用于指定 Flask 应用程序的入口文件。</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_RUN_HOST <span class="number">0.0</span>.<span class="number">0.0</span>												<span class="comment">#设置环境变量 FLASK_RUN_HOST 的值为 0.0.0.0，指定 Flask 应用程序监听的主机地址。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories	<span class="comment">#使用 sed 命令替换 /etc/apk/repositories 文件中的源地址，将默认的 Alpine Linux 镜像源替换为阿里云镜像源。</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache gcc musl-dev linux-headers		<span class="comment">#安装 Alpine Linux 发行版中的一些构建依赖，包括 gcc、musl-dev 和 linux-headers。</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt							<span class="comment">#将主机中的 requirements.txt 文件复制到容器的当前工作目录 /code。</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -U pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip config <span class="built_in">set</span> global.index-url http://mirrors.aliyun.com/pypi/simple		<span class="comment">#配置 pip 使用阿里云镜像源作为全局索引地址。</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip config <span class="built_in">set</span> install.trusted-host mirrors.aliyun.com		<span class="comment">#配置 pip 信任阿里云镜像源的主机。</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .																			<span class="comment">#将主机中的所有文件复制到容器的当前工作目录 /code。</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;flask&quot;</span>, <span class="string">&quot;run&quot;</span>]														<span class="comment">#在容器启动时执行的默认命令，启动 Flask 应用程序。</span></span></span><br></pre></td></tr></table></figure></div>

<p>通过这个 YAML 文件，可以构建一个包含 Flask 应用程序及其依赖的 Docker 镜像，并在容器中运行该应用程序。</p>
<p><strong>创建文件requirements.txt</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>docker-compose.yml</p>
</blockquote>
<p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="运行-compose-项目"><a href="#运行-compose-项目" class="headerlink" title="运行 compose 项目"></a>运行 compose 项目</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up </span><br><span class="line">Recreating composetest_web_1 ... <span class="keyword">done</span></span><br><span class="line">Starting composetest_redis_1 ... <span class="keyword">done</span></span><br><span class="line">Attaching to composetest_redis_1, composetest_web_1</span><br><span class="line">redis_1  | 1:C 18 May 2020 08:47:26.039 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">redis_1  | 1:C 18 May 2020 08:47:26.039 <span class="comment"># Redis version=6.0.2, bits=64, commit=00000000, modified=0, pid=1, just started</span></span><br><span class="line">redis_1  | 1:C 18 May 2020 08:47:26.039 <span class="comment"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span></span><br><span class="line">redis_1  | 1:M 18 May 2020 08:47:26.041 * Running mode=standalone, port=6379.</span><br><span class="line">redis_1  | 1:M 18 May 2020 08:47:26.041 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">redis_1  | 1:M 18 May 2020 08:47:26.041 <span class="comment"># Server initialized</span></span><br><span class="line">redis_1  | 1:M 18 May 2020 08:47:26.041 <span class="comment"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span></span><br><span class="line">redis_1  | 1:M 18 May 2020 08:47:26.042 * Loading RDB produced by version 6.0.2</span><br><span class="line">redis_1  | 1:M 18 May 2020 08:47:26.042 * RDB age 27 seconds</span><br><span class="line">redis_1  | 1:M 18 May 2020 08:47:26.042 * RDB memory usage when created 0.77 Mb</span><br><span class="line">redis_1  | 1:M 18 May 2020 08:47:26.042 * DB loaded from disk: 0.000 seconds</span><br><span class="line">redis_1  | 1:M 18 May 2020 08:47:26.042 * Ready to accept connections</span><br><span class="line">web_1    |  * Serving Flask app <span class="string">&quot;app.py&quot;</span></span><br><span class="line">web_1    |  * Environment: production</span><br><span class="line">web_1    |    WARNING: This is a development server. Do not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line">web_1    |    Use a production WSGI server instead.</span><br><span class="line">web_1    |  * Debug mode: off</span><br><span class="line">web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure></div>

<p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230529184825067.png"
                      class="" title="image-20230529184825067"
                >



<blockquote>
<p>添加挂载,重跑 compose</p>
</blockquote>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span>					</span><br><span class="line"><span class="attr">services:</span>						<span class="comment">#定义的服务（容器）列表开始					</span></span><br><span class="line">  <span class="attr">web:</span>							<span class="comment">#定义了名为”web“服务，下面的缩进块是该服务的配置</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>					<span class="comment">#使用当前的目录下的Dockerfile来构建该服务的镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span>				<span class="comment">#将当前目录与容器内部的 /code 目录进行挂载，使得容器内部的文件变动可以在宿主机上同步</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">FLASK_ENV:</span> <span class="string">development</span>		<span class="comment">#设置环境变量 FLASK_ENV 为 development，该环境变量将传递给容器中的应用程序</span></span><br><span class="line">  <span class="attr">redis:</span>											<span class="comment">#这里定义了另一个服务，名为 &quot;redis&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span>					<span class="comment">#使用 Redis 镜像中的 Alpine 版本作为该服务的镜像。</span></span><br></pre></td></tr></table></figure></div>

<p>volumes：将当前目录挂载到&#x2F;code里面 environment： 设置flask以development模式运行</p>
<h2 id="Compose命令说明"><a href="#Compose命令说明" class="headerlink" title="Compose命令说明"></a>Compose命令说明</h2><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。<u>如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</u></p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>
<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>
<li><code>--verbose</code> 输出更多调试信息。</li>
<li><code>-v, --version</code> 打印版本并退出。</li>
</ul>
<h3 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h3><blockquote>
<p>build</p>
</blockquote>
<p>构建（重新构建）项目中的服务容器，格式为 <code>docker-compose build [options] [SERVICE...]</code>。服务容器一旦构建后，将会带上一个标记名（名称）<strong>，可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</strong></p>
<p>选项包括：</p>
<ul>
<li><code>--force-rm</code> 删除构建过程中的临时容器。</li>
<li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li>
<li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li>
</ul>
<p><strong>config：</strong>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<p><strong>down：</strong>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<p><strong>exec：</strong>进入指定的容器。</p>
<p><strong>help：</strong>获得一个命令的帮助。</p>
<p><strong>images：</strong>列出 Compose 文件中包含的镜像。</p>
<p><strong>kill：</strong>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure></div>

<p><strong>logs：</strong>查看服务容器的输出，格式为 <code>docker-compose logs [options] [SERVICE...]</code>。<strong>默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分</strong>。可以通过 <code>--no-color</code> 来关闭颜色。该命令在调试问题的时候十分有用。</p>
<p><strong>pause：</strong>暂停一个服务容器，格式为 <code>docker-compose pause [SERVICE...]</code>。</p>
<p><strong>port：</strong>打印某个容器端口所映射的公共端口，格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p>
<p>选项：</p>
<ul>
<li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li>
<li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li>
</ul>
<p><code>ps：</code>列出项目中目前的所有容器，格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<p><strong>pull：</strong>拉取服务依赖的镜像，格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p>
<p>选项：</p>
<ul>
<li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li>
</ul>
<p><strong>push：</strong>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<p><strong>restart：</strong>重启项目中的服务，格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<p><strong>rm：</strong>格式为 删除所有（停止状态的）服务容器，<code>docker-compose rm [options] [SERVICE...]</code>。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><strong><code>-v</code> 删除容器所挂载的数据卷。</strong></li>
</ul>
<p><strong>run：</strong>在指定服务上执行一个命令，格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure></div>

<p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。<strong>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</strong>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li>给定命令将会覆盖原有的自动运行命令；</li>
<li><strong>不会自动创建端口，以避免冲突。</strong></li>
</ul>
<p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，将不会启动 web 容器所关联的其它容器。例如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure></div>

<p>选项：</p>
<ul>
<li><code>-d</code> 后台运行容器。</li>
<li><code>--name NAME</code> 为容器指定一个名字。</li>
<li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li>
<li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li>
<li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li>
<li><code>--no-deps</code> 不自动启动关联的服务容器。</li>
<li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li>
<li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li>
<li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li>
<li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li>
</ul>
<p><strong>scale：</strong>设置指定服务运行的容器个数，格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。通过 <code>service=num</code> 的参数来设置数量。例如：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure></div>

<p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p>
<p><strong>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</strong></p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><strong>start：</strong>格式为 启动已经存在的服务容器，<code>docker-compose start [SERVICE...]</code>。</p>
<p><strong>stop：</strong>停止已经处于运行状态的容器，但不删除它，格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><strong>top：查看各个服务容器内运行的进程。</strong></p>
<p><strong>unpause：</strong>恢复处于暂停状态中的服务，格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p><strong>up：</strong></p>
<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。链接的服务都将会被自动启动，除非已经处于运行状态。默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后<strong>重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</strong>。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 在后台运行服务容器。</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，<strong>不能与 <code>--no-recreate</code> 同时使用。</strong></li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，<strong>不能与 <code>--force-recreate</code> 同时使用。</strong></li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像。</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>version</code>打印版本信息，格式为 <code>docker-compose version</code>。</p>
<h2 id="Compose模板文件"><a href="#Compose模板文件" class="headerlink" title="Compose模板文件"></a>Compose模板文件</h2><p>编写之前，注意下Compose和Docker兼容性：</p>
<ul>
<li>Compose 文件格式有3个版本,分别为1, 2.x 和 3.x</li>
<li>目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本</li>
</ul>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">examples/web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/data&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p><u>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</u></p>
<blockquote>
<p>build</p>
</blockquote>
<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure></div>



<p>也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。使用 <code>arg</code> 指令指定构建镜像时的变量。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>



<p>使用 <code>cache_from</code> 指定构建镜像的缓存</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">cache_from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">alpine:latest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>cap_add,cap_drop</p>
</blockquote>
<p><strong>容器的内核能力是指容器在运行时可以访问和使用的内核功能和资源。</strong>容器是在宿主操作系统上创建的一种隔离环境，它共享宿主操作系统的内核。容器的内核能力决定了容器可以执行的操作和访问的资源范围。</p>
<p>例如，让容器拥有所有能力可以指定为：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ALL</span></span><br></pre></td></tr></table></figure></div>

<p>去掉 NET_ADMIN 能力可以指定为：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>command</p>
</blockquote>
<p>覆盖容器启动后默认执行的命令。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>cgroup_parent</p>
</blockquote>
<p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p>
<p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">cgroups_1</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>当创建一个容器时，可以通过设置 <code>cgroup_parent</code> 属性来指定容器所属的 cgroup 父级。这样做可以实现对容器的资源管理和隔离。</p>
</blockquote>
<blockquote>
<p>container_name</p>
</blockquote>
<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</strong></p>
<blockquote>
<p>devices</p>
</blockquote>
<p>在Docker中，设备映射关系是一种机制，用于将主机的设备或设备节点映射到容器中，以便容器可以访问和使用这些设备。这样可以在容器内部使用主机上的设备或资源，提供更多的灵活性和功能。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;/dev/ttyUSB1:/dev/ttyUSB0&quot;</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>depends on</p>
</blockquote>
<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动</strong></p>
<blockquote>
<p>dns</p>
</blockquote>
<p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>dns_search</p>
</blockquote>
<p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain1.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>tmpfs</p>
</blockquote>
<p>挂载一个 tmpfs 文件系统到容器。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/run</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>env_file</p>
</blockquote>
<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p><strong>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</strong></p>
<p><strong>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .<span class="built_in">env</span></span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure></div>

<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>emvironment</p>
</blockquote>
<p>设置环境变量。你可以使用数组或字典两种格式。<strong>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值</strong>，可以用来防止泄露不必要的数据。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure></div>

<p><strong>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a class="link"   target="_blank" rel="noopener" href="https://yaml.org/type/bool.html" >布尔 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 含义的词汇，最好放到引号里</strong>，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|<span class="built_in">yes</span>|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>expose</p>
</blockquote>
<p><strong>暴露端口，但不映射到宿主机，只被连接的服务访问</strong>。仅可以指定内部端口为参数</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>external_links</p>
</blockquote>
<p><strong>注意：不建议使用该指令。</strong></p>
<p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">external_links:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">redis_1</span>											<span class="comment">#链接到名为redis_1的外部容器</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:mysql</span>						<span class="comment">#链接到名为project_db_1的外部容器，并指定别名为mysql。这意味着当前服务可以通过别名mysql访问外部容器project_db_1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:postgresql</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>extra_hosts</p>
</blockquote>
<p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span>			<span class="comment">#用于将自定义的主机名与 IP 地址对进行映射。这样可以在容器内部使用自定义的主机名来访问特定的 IP 地址</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;googledns:8.8.8.8&quot;</span>		<span class="comment">#将主机名googledns映射到 IP 地址8.8.8.8。在容器内部，可以使用主机名googledns来访问 IP 地址8.8.8.8，而不需要使用 IP 地址直接访问。</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;dockerhub:52.1.157.61&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>healthcheck</p>
</blockquote>
<p>通过命令检查容器是否健康运行。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<p><code>test</code>具体解释如下：</p>
<ul>
<li><code>CMD</code>：表示要执行一个命令进行健康检查。</li>
<li><code>curl</code>：健康检查命令的实际命令部分，这里使用 <code>curl</code> 工具进行健康检查。</li>
<li><code>-f</code>：<code>curl</code> 命令的选项之一，表示在请求过程中，如果返回的 HTTP 状态码不为 2xx（成功）时，不输出错误信息，直接退出。</li>
<li><code>http://localhost</code>：健康检查的目标 URL，这里是检查容器内部的 localhost 地址。</li>
</ul>
<blockquote>
<p>image</p>
</blockquote>
<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>label</p>
</blockquote>
<p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">com.startupteam.description:</span> <span class="string">&quot;webapp for a startup team&quot;</span></span><br><span class="line">  <span class="attr">com.startupteam.department:</span> <span class="string">&quot;devops department&quot;</span></span><br><span class="line">  <span class="attr">com.startupteam.release:</span> <span class="string">&quot;rc3 for v1.0&quot;</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>logging</p>
</blockquote>
<p>配置日志选项。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">syslog</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">syslog-address:</span> <span class="string">&quot;tcp://192.168.0.42:123&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>目前支持三种日志驱动类型。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">&quot;syslog&quot;</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><code>options</code> 配置日志驱动的相关参数。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">max-size:</span> <span class="string">&quot;200k&quot;</span></span><br><span class="line">  <span class="attr">max-file:</span> <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>driver: &quot;json-file&quot;</code>：这是默认的日志驱动程序，它将容器的日志输出写入到 JSON 格式的文件中。每个容器的日志会被保存在宿主机上，通常位于 <code>/var/lib/docker/containers/&lt;container_id&gt;/&lt;container_id&gt;-json.log</code> 路径下。这种日志驱动程序适用于大多数情况，可以方便地查看和管理容器的日志。</p>
</li>
<li><p><code>driver: &quot;syslog&quot;</code>：这种日志驱动程序将容器的日志输出发送到系统的 syslog 服务。它可以将容器的日志与宿主机的系统日志集中在一起，方便管理和监控。使用 syslog 日志驱动程序可以将容器的日志集成到现有的日志系统中。</p>
</li>
<li><p><code>driver: &quot;none&quot;</code>：这种日志驱动程序表示容器的日志将不会被记录。容器的输出不会被重定向到任何地方，无法查看或检索容器的日志。这种配置适用于不需要记录容器日志的特殊情况，或者在特定的测试或调试场景中使用。</p>
</li>
</ul>
<blockquote>
<p>network_mode</p>
</blockquote>
<p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;service:[service name]&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;container:[container name/id]&quot;</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>networks</p>
</blockquote>
<p>配置容器连接的网络。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">some-network</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>pid</p>
</blockquote>
<p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid:</span> <span class="string">&quot;host&quot;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>将 <code>pid: &quot;host&quot;</code> 配置应用于容器时，容器将与宿主机共享相同的 PID 命名空间，<strong>这意味着容器内部的进程可以看到宿主机上的所有进程，就像它们是在同一个命名空间中运行一样。</strong>这样做的效果是容器内的进程可以直接访问和操作宿主机上的进程，例如查看宿主机的进程列表、发送信号给宿主机上的进程等。</p>
</blockquote>
<blockquote>
<p>ports</p>
</blockquote>
<p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（<strong>宿主将会随机选择端口</strong>）都可以。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;49100:22&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，<strong>建议数字串都采用引号包括起来的字符串格式。</strong></em></p>
<blockquote>
<p>secrets</p>
</blockquote>
<p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.1&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span>			<span class="comment">#此处将 MYSQL_ROOT_PASSWORD_FILE 的值设置为一个文件路径，而不是直接指定密码。这个文件路径应该指向一个 Docker 密钥文件。</span></span><br><span class="line">  <span class="attr">secrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">db_root_password</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my_other_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="attr">my_secret:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./my_secret.txt</span></span><br><span class="line">  <span class="attr">my_other_secret:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span>			<span class="comment">#指定密钥是一个外部密钥，不会在当前 Docker Compose 文件中定义。这意味着密钥需要在其他地方提前定义，以便在运行时被引用。</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>security_opt</p>
</blockquote>
<p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:user:USER</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:role:ROLE</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>stop_signal</p>
</blockquote>
<p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>当需要停止容器时，Docker 默认会发送 <code>SIGTERM</code> 信号给容器的主进程，并等待一段时间（默认为 10 秒）让容器自行停止。如果容器在规定时间内没有自行停止，Docker 将发送 <code>SIGKILL</code> 信号来强制终止容器。</p>
<p>通过使用 <code>stop_signal</code> 选项，可以指定自定义的停止信号。这在某些情况下很有用，例如，当容器中的应用程序接收到特定信号时才能正确地进行清理和停止。</p>
<p>例如，可以将 <code>stop_signal</code> 设置为 <code>SIGINT</code>，即 <code>Ctrl+C</code> 信号。这样，在停止容器时，Docker 将发送 <code>SIGINT</code> 信号给容器的主进程，而不是默认的 <code>SIGTERM</code> 信号。</p>
</blockquote>
<blockquote>
<p>sysctls</p>
</blockquote>
<p>配置容器内核参数。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="attr">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="attr">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure></div>

<p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>volumes</p>
</blockquote>
<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>
<p>该指令中路径支持相对路径。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/var/lib/mysql</span>							<span class="comment">#匿名卷是 Docker 在主机上自动生成的一个唯一名称的卷。</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cache/:/tmp/cache</span>					<span class="comment">#将主机上的 cache/ 目录挂载到容器内的 /tmp/cache 目录。具名卷是由用户定义的卷，并且可以在多个容器之间共享。</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro</span>		<span class="comment">#将主机上的 ~/configs 目录挂载到容器内的 /etc/configs 目录，并设置为只读（read-only）。这意味着容器内部只能读取这个目录的内容，而不能对其进行写入操作。</span></span><br></pre></td></tr></table></figure></div>

<p><strong>如果路径为数据卷名称，必须在文件中配置数据卷。</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_src:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>其它指令</p>
</blockquote>
<p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p>
<p><strong>指定服务容器启动后执行的入口文件。</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure></div>

<p>指定容器中运行应用的用户名。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure></div>

<p>指定容器中工作目录。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">working_dir:</span> <span class="string">/code</span></span><br></pre></td></tr></table></figure></div>

<p>指定容器中搜索域名、主机名、mac 地址等。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">domainname:</span> <span class="string">your_website.com</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">mac_address:</span> <span class="number">08</span><span class="number">-00</span><span class="number">-27</span><span class="number">-00</span><span class="string">-0C-0A</span></span><br></pre></td></tr></table></figure></div>

<p>允许容器中运行一些特权命令。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></div>

<p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">read_only:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<p><strong>打开标准输入，可以接受外部输入。</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stdin_open:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<p><strong>模拟一个伪终端。</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>读取变量</p>
</blockquote>
<p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>$&#123;MONGO_VERSION&#125;</code> 的值，并写入执行的指令中。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">&quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>如果执行 <code>docker-compose up -e MONGO_VERSION=3.2</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code> docker-compose up -e MONGO_VERSION=2.8</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p>
<p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p>
<p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure></div>

<p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>
<h2 id="实战WordPress"><a href="#实战WordPress" class="headerlink" title="实战WordPress"></a>实战WordPress</h2><p><strong>创建空文件夹</strong></p>
<p>新建一个名为 <code>wordpress</code> 的文件夹，然后进入这个文件夹。</p>
<p><strong>创建<code>docker-compose.yml</code>文件</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定 docker-compose.yml 文件的版本</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义所有的 service 信息, services 下面的第一级别的 key 既是一个 service 的名称</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">   <span class="attr">db:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">db_data:/var/lib/mysql</span></span><br><span class="line">     <span class="comment"># 定义容器重启策略</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="comment"># 设置环境变量， environment 的值可以覆盖 env_file 的值 </span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line">       <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">wordpress:</span></span><br><span class="line">     <span class="comment">#docker-compose up 以依赖顺序启动服务，先启动db</span></span><br><span class="line">     <span class="attr">depends_on:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">     <span class="comment"># 建立宿主机和容器之间的端口映射关系,容器的 80 端口和宿主机的 8000 端口建立映射关系</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;8000:80&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="comment"># 定义容器和宿主机的卷映射关系, 其和 networks 一样可以位于 services 键的二级key和 compose 顶级key, 如果需要跨服务间使用则在顶级key定义, 在 services 中引用</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="attr">db_data:</span> &#123;&#125;					<span class="comment">#在 services 下的服务中引用这些卷；db_data: &#123;&#125; 表示定义了一个空的卷（Volume）db_data。通过使用大括号 &#123;&#125; 表示一个空的卷配置，表示没有进一步的配置项或参数。</span></span><br></pre></td></tr></table></figure></div>



<p><strong>构建并运行项目</strong></p>
<p>运行 <code>docker-compose up -d</code> Compose 就会拉取镜像再创建我们所需要的镜像，然后启动 <code>wordpress</code> 和数据库容器。 接着浏览器访问 <code>127.0.0.1:8000</code> 端口就能看到 <code>WordPress</code> 安装界面了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530091117121.png"
                      class="" title="image-20230530091117121"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530091205598.png"
                      class="" title="image-20230530091205598"
                >



<h1 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h1><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><blockquote>
<p>登录</p>
</blockquote>
<p>通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。通过 <code>docker logout</code> 退出登录。</p>
<blockquote>
<p>拉取镜像</p>
</blockquote>
<p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<p>例如以 <code>centos</code> 为关键词进行搜索：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530092341732.png"
                      class="" title="image-20230530092341732"
                >

<p>根据是否是官方提供，可将镜像分为两类：</p>
<p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
<p>还有一种类型，比如 <code>tianon/centos</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 tianon 用户。</p>
<p><strong>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530092547672.png"
                      class="" title="image-20230530092547672"
                >

<p>下载官方 <code>ubuntu</code> 镜像到本地。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu</span><br><span class="line">Pulling repository ubuntu</span><br><span class="line">0b443ba03958: Download complete</span><br><span class="line">539c0211cd76: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">7064731afe90: Download complete</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>推送镜像</p>
</blockquote>
<p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 airex/ubuntu:18.04		<span class="comment">#通过执行该命令，为现有的镜像创建了一个新的标签，相当于为该镜像创建了一个别名。这样可以通过不同的标签来引用同一个镜像，方便在不同场景下使用不同的标识符</span></span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                        18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                       18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker search airex</span><br><span class="line"></span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">airex/ubuntu</span><br></pre></td></tr></table></figure></div>





<blockquote>
<p>自动构建</p>
</blockquote>
<p>自动构建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a class="link"   target="_blank" rel="noopener" href="https://github.com/" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 或 <a class="link"   target="_blank" rel="noopener" href="https://bitbucket.org/" >BitBucket <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动构建，包括如下的步骤：</p>
<ul>
<li>登录 Docker Hub；</li>
<li>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</li>
<li>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</li>
<li>指定 <code>Dockerfile</code> 的位置，并保存。</li>
</ul>
<p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530094119225.png"
                      class="" title="image-20230530094119225"
                >



<h2 id="私有仓库-1"><a href="#私有仓库-1" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。<a target="_blank" rel="noopener" href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a target="_blank" rel="noopener" href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。registry镜像是Docker官方提供的用于搭建和管理Docker镜像仓库的镜像。<strong>它提供了一个私有的、本地的镜像仓库，用于存储和共享Docker镜像。</strong>使用”registry”镜像可以轻松地创建一个本地的镜像仓库，并将自己构建的Docker镜像推送到该仓库中，以便在局域网内共享和使用。</p>
<p>默认运行端口是5000，当运行registry容器时，可以将主机的5000端口映射到容器的5000端口，以便通过主机的5000端口访问registry仓库。</p>
<blockquote>
<p>安装运行docker-registry，创建私有仓库</p>
</blockquote>
<p>获取官方 <code>registry</code> 镜像来运行。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure></div>

<p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。<strong>你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径</strong>。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \				<span class="comment">#windows本地主机路径 : 容器路径</span></span><br><span class="line">    registry</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>在私有仓库上传、搜索、下载镜像</p>
</blockquote>
<p><strong>本节实验在服务器中完成</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag busybox 127.0.0.1:5000/busybox</span><br><span class="line"> docker push 127.0.0.1:5000/busybox</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530134925856.png"
                      class="" title="image-20230530134925856"
                >

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:5000/v2/_catalog</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530135241669.png"
                      class="" title="image-20230530135241669"
                >

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image rmi 127.0.0.1:5000/busybox			<span class="comment">#删除镜像</span></span><br><span class="line">docker pull 127.0.0.1:5000/busybox					<span class="comment">#拉取镜像</span></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530135811529.png"
                      class="" title="image-20230530135811529"
                >



<blockquote>
<p>补充</p>
</blockquote>
<p>如果不使用 <code>127.0.0.1:5000</code> 作为仓库地址，例如将类似 <code>192.168.199.100:5000</code> 的内网地址作为私有仓库地址，无法成功推送镜像。这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/init/docker.conf</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530140651661.png"
                      class="" title="image-20230530140651661"
                >

<p>修改后重启Docker服务</p>
<blockquote>
<p>Ubuntu16.04+,Debian8+,centos7</p>
</blockquote>
<p><code>systemd</code>系统提供了一种更现代、更灵活和更高效的方式来管理Linux系统，使系统管理更加方便和可靠。对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirror&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;192.168.199.100:5000&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。<strong>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 <code>Docker Engine</code> 中进行编辑 ，增加和上边一样的字符串即可。</strong></p>
<h2 id="推送镜像到阿里云"><a href="#推送镜像到阿里云" class="headerlink" title="推送镜像到阿里云"></a>推送镜像到阿里云</h2><p>1.进入阿里云控制台，选择容器镜像服务</p>
<p>2.创建个人版实例</p>
<p>3.设置registry密码</p>
<p>4.创建命名空间，设置状态为开始、公开</p>
<p>5.以“本地仓库”方式创建镜像仓库，设置状态公开</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530150427202.png"
                      class="" title="image-20230530150427202"
                >



<h3 id="操作指南"><a href="#操作指南" class="headerlink" title="操作指南"></a>操作指南</h3><blockquote>
<ol>
<li>登录阿里云Docker Registry</li>
</ol>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login --username=airexyu registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure></div>

<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。可以在访问凭证页面修改凭证密码。</p>
<blockquote>
<ol start="2">
<li>从Registry中拉取镜像</li>
</ol>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull registry.cn-hangzhou.aliyuncs.com/airex_study/study:[镜像版本号]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<ol start="3">
<li>将镜像推送到Registry</li>
</ol>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker login --username=airexyu registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/airex_study/study:[镜像版本号]</span><br><span class="line">$ docker push registry.cn-hangzhou.aliyuncs.com/airex_study/study:[镜像版本号]</span><br></pre></td></tr></table></figure></div>

<p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p>
<blockquote>
<ol start="4">
<li>选择合适的镜像仓库地址</li>
</ol>
</blockquote>
<p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p>
<blockquote>
<p>VPC（Virtual Private Cloud）网络是在公共云环境下搭建起来的一组逻辑隔离的网络空间。它能够和云服务进行灵活扩容配合和访问控制以及多层次的安全策略。</p>
<p>VPC网络可以在云服务商的公共云环境下为用户分配一个私有的IP地址段，使得用户可以自主地创建、配置和管理虚拟私有网络、子网、路由表、安全组等网络资源，构建适合自身应用场景的网络拓扑结构</p>
</blockquote>
<p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。</p>
<blockquote>
<ol start="5">
<li>示例</li>
</ol>
</blockquote>
<p>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530153258742.png"
                      class="" title="image-20230530153258742"
                >

<p>使用 “docker push” 命令将该镜像推送至远程。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/airex_study/study:latest</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530153327270.png"
                      class="" title="image-20230530153327270"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/05/26/Docker/image-20230530153439471.png"
                      class="" title="image-20230530153439471"
                >


            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> Docker</li>
        <li><strong>作者:</strong> Airex Yu</li>
        <li><strong>创建于:</strong> 2023-05-26 09:31:49</li>
        
            <li>
                <strong>更新于:</strong> 2023-07-02 15:13:45
            </li>
        
        <li>
            <strong>链接:</strong> http://example.com/2023/05/26/Docker/
        </li>
        <li>
            <strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
        </li>
    </ul>
</div>

                </div>
            

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/06/02/shell/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">shell</span>
                                    <span class="post-nav-item">上一篇</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/04/13/J5/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">J5</span>
                                    <span class="post-nav-item">下一篇</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
                <div class="comment-container">
                    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;评论
    </div>
    

        
            
 
    <div id="waline"></div>
    <script type="module"  data-pjax>
        import { init } from 'https://evan.beee.top/js/waline.mjs';

        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://example.example.com',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
            });
        }

        if ('true') {
            const loadWalineTimeout = setTimeout(() => {
                loadWaline();
                clearTimeout(loadWalineTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadWaline);
        }
        
    </script>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">Docker</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85"><span class="nav-text">Docker 简介和安装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-text">安装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6"><span class="nav-text">Docker 快速安装软件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-text">更多相关命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-text">制作自己的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DockerFile%E6%96%87%E4%BB%B6"><span class="nav-text">DockerFile文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-text">构建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-text">指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA"><span class="nav-text">导入与导出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD"><span class="nav-text">目录挂载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95"><span class="nav-text">命令用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bind"><span class="nav-text">bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volume"><span class="nav-text">volume</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tmpfs"><span class="nav-text">tmpfs</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%80%9A%E4%BF%A1"><span class="nav-text">多容器通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="nav-text">Docker网络模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bridge%E6%96%B9%E5%BC%8F%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="nav-text">bridge方式（默认）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#none%E6%96%B9%E5%BC%8F"><span class="nav-text">none方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#host%E6%96%B9%E5%BC%8F"><span class="nav-text">host方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#container%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">container复用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-defined%E6%A8%A1%E5%BC%8F"><span class="nav-text">user-defined模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8"><span class="nav-text">外部访问容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80"><span class="nav-text">映射所有接口地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80"><span class="nav-text">指定端口映射到指定地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80"><span class="nav-text">任意端口映射到指定地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="nav-text">查看映射端口配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text">容器间通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Compose"><span class="nav-text">Docker Compose</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%9C%89%E5%8D%B8%E8%BD%BD"><span class="nav-text">安装有卸载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85"><span class="nav-text">二进制包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PIP%E5%AE%89%E8%A3%85"><span class="nav-text">PIP安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bash-%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">bash 补全命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD"><span class="nav-text">卸载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#YAML%E6%96%87%E4%BB%B6"><span class="nav-text">YAML文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#web-%E5%BA%94%E7%94%A8"><span class="nav-text">web 应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C-compose-%E9%A1%B9%E7%9B%AE"><span class="nav-text">运行 compose 项目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compose%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="nav-text">Compose命令说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="nav-text">命令说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compose%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6"><span class="nav-text">Compose模板文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98WordPress"><span class="nav-text">实战WordPress</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="nav-text">私有仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Hub"><span class="nav-text">Docker Hub</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93-1"><span class="nav-text">私有仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="nav-text">推送镜像到阿里云</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97"><span class="nav-text">操作指南</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Airex Yu</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br>
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.1.5</a>
        </div>
        
        
        
            <div id="start_div" style="display:none">
                2023/01/05 11:45:14
            </div>
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>



    
<script src="/js/tools/localSearch.js"></script>




    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>




    
<script src="/js/libs/mermaid.min.js"></script>

    
<script src="/js/plugins/mermaid.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/tools/tocToggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
